<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Agda佐恩引理</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script type="text/javascript" src="highlight-hover.js"></script>
</head>
<body>

<header>
<h1 class="title">Agda佐恩引理</h1>
<blockquote class="metadata">
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#agda佐恩引理" id="toc-agda佐恩引理">Agda佐恩引理</a>
  <ul>
  <li><a href="#前言" id="toc-前言">前言</a></li>
  <li><a href="#序理论" id="toc-序理论">序理论</a>
  <ul>
  <li><a href="#偏序" id="toc-偏序">偏序</a></li>
  <li><a href="#无界" id="toc-无界">无界</a></li>
  <li><a href="#最大元" id="toc-最大元">最大元</a></li>
  <li><a href="#链" id="toc-链">链</a></li>
  <li><a href="#上界" id="toc-上界">上界</a></li>
  <li><a href="#上确界" id="toc-上确界">上确界</a></li>
  <li><a href="#佐恩引理的表述" id="toc-佐恩引理的表述">佐恩引理的表述</a></li>
  </ul></li>
  <li><a href="#链集的链" id="toc-链集的链">链集的链</a>
  <ul>
  <li><a href="#偏序-1" id="toc-偏序-1">偏序</a></li>
  <li><a href="#上确界-1" id="toc-上确界-1">上确界</a></li>
  <li><a href="#后继性" id="toc-后继性">后继性</a></li>
  </ul></li>
  <li><a href="#构造矛盾" id="toc-构造矛盾">构造矛盾</a>
  <ul>
  <li><a href="#归纳构造塔" id="toc-归纳构造塔">归纳构造”塔”</a></li>
  <li><a href="#塔也是链" id="toc-塔也是链">“塔”也是链</a></li>
  <li><a href="#矛盾" id="toc-矛盾">矛盾</a></li>
  </ul></li>
  <li><a href="#选择公理" id="toc-选择公理">选择公理</a></li>
  <li><a href="#佐恩引理的证明" id="toc-佐恩引理的证明">佐恩引理的证明</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="agda佐恩引理">Agda佐恩引理</h1>
<h2 id="前言">前言</h2>
<p>佐恩引理是经典数学中最基础的定理之一. 然而, 作为直觉主义数学的前沿之一, 同伦类型论 (HoTT) 在经典领域的扩展并未获得太多研究关注. 本文旨在填补这一空白, 我们将在同伦类型论的框架下展示对佐恩引理这一经典定理的证明. 尽管本文的内容可以被视为 Agda 代码的注释, 我们仍然力求使其内容对于不熟悉 Agda 语言的读者也能理解其中的主要思路, 但前提是读者需要了解同伦类型论的基本概念. 例如我们会涉及到 <strong>命题截断 (propositional truncation)</strong> 和 <strong>命题宇宙调整</strong> (propositional resizing) 等概念, 需要读者对它们有一些基本了解.</p>
<p>我们工作在无公理的 cubical 环境中, 而选择公理将作为参数引入. 这里说的 cubical 指立方类型论 (cubical type theory), 它是同伦类型论的一种实现.</p>
<pre class="Agda"><a id="454" class="Symbol">{-#</a> <a id="458" class="Keyword">OPTIONS</a> <a id="466" class="Pragma">--cubical</a> <a id="476" class="Pragma">--safe</a> <a id="483" class="Symbol">#-}</a>
<a id="487" class="Symbol">{-#</a> <a id="491" class="Keyword">OPTIONS</a> <a id="499" class="Pragma">--lossy-unification</a> <a id="519" class="Symbol">#-}</a>

<a id="524" class="Keyword">module</a> <a id="531" href="CubicalExt.Logic.Zorn.html" class="Module">CubicalExt.Logic.Zorn</a> <a id="553" class="Keyword">where</a>
</pre>
<p>首先, 我们需要导入 Cubical 标准库模块. 同伦类型论 (乃至其立方类型论实现) 以其对”相等”这一基础概念的复杂诠释而广为人知. 在某些情况下 (如单集的定义中), 我们将使用立方类型论的 <code>Id</code> 类型, 因其可以便捷地进行模式匹配. 然而, 在大部分情况下, 我们更倾向于使用路径 <code>Path</code> 类型.</p>
<pre class="Agda"><a id="732" class="Keyword">open</a> <a id="737" class="Keyword">import</a> <a id="744" href="Cubical.Core.Id.html" class="Module">Cubical.Core.Id</a> <a id="760" class="Keyword">using</a> <a id="766" class="Symbol">(</a><a id="767" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="773" class="Symbol">)</a>
<a id="775" class="Keyword">open</a> <a id="780" class="Keyword">import</a> <a id="787" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="815" class="Keyword">hiding</a> <a id="822" class="Symbol">(</a><a id="823" href="Cubical.Core.Primitives.html#403" class="Primitive">_∧_</a><a id="826" class="Symbol">;</a> <a id="828" href="Cubical.Core.Primitives.html#452" class="Primitive">_∨_</a><a id="831" class="Symbol">)</a>
<a id="833" class="Keyword">open</a> <a id="838" class="Keyword">import</a> <a id="845" href="Cubical.Foundations.HLevels.html" class="Module">Cubical.Foundations.HLevels</a>
<a id="873" class="Keyword">open</a> <a id="878" class="Keyword">import</a> <a id="885" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a> <a id="917" class="Keyword">using</a> <a id="923" class="Symbol">(</a><a id="924" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a><a id="927" class="Symbol">)</a>
<a id="929" class="Keyword">open</a> <a id="934" class="Keyword">import</a> <a id="941" href="Cubical.Data.Empty.html" class="Module">Cubical.Data.Empty</a> <a id="960" class="Symbol">as</a> <a id="963" class="Module">⊥</a> <a id="965" class="Keyword">using</a> <a id="971" class="Symbol">(</a><a id="972" href="Cubical.Data.Empty.Base.html#145" class="Datatype">⊥</a><a id="973" class="Symbol">;</a> <a id="975" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a><a id="982" class="Symbol">)</a>
<a id="984" class="Keyword">open</a> <a id="989" class="Keyword">import</a> <a id="996" href="Cubical.Data.Sigma.html" class="Module">Cubical.Data.Sigma</a> <a id="1015" class="Keyword">using</a> <a id="1021" class="Symbol">(</a><a id="1022" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃-syntax</a><a id="1030" class="Symbol">;</a> <a id="1032" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a><a id="1038" class="Symbol">;</a> <a id="1040" href="Cubical.Data.Sigma.Properties.html#2119" class="Function">PathPΣ</a><a id="1046" class="Symbol">)</a>
<a id="1048" class="Keyword">import</a> <a id="1055" href="Cubical.Data.Sum.html" class="Module">Cubical.Data.Sum</a> <a id="1072" class="Symbol">as</a> <a id="1075" class="Module">⊎</a>
<a id="1077" class="Keyword">open</a> <a id="1082" class="Keyword">import</a> <a id="1089" href="Cubical.HITs.PropositionalTruncation.html" class="Module">Cubical.HITs.PropositionalTruncation</a> <a id="1126" class="Keyword">using</a> <a id="1132" class="Symbol">(</a><a id="1133" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥_∥₁</a><a id="1137" class="Symbol">;</a> <a id="1139" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a><a id="1143" class="Symbol">;</a> <a id="1145" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a><a id="1152" class="Symbol">;</a> <a id="1154" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a><a id="1157" class="Symbol">;</a> <a id="1159" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a><a id="1163" class="Symbol">;</a> <a id="1165" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a><a id="1168" class="Symbol">)</a>
<a id="1170" class="Keyword">open</a> <a id="1175" class="Keyword">import</a> <a id="1182" href="Cubical.Relation.Nullary.html" class="Module">Cubical.Relation.Nullary</a> <a id="1207" class="Keyword">using</a> <a id="1213" class="Symbol">(</a><a id="1214" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬_</a><a id="1216" class="Symbol">;</a> <a id="1218" href="Cubical.Relation.Nullary.Base.html#444" class="Datatype">Dec</a><a id="1221" class="Symbol">;</a> <a id="1223" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a><a id="1226" class="Symbol">;</a> <a id="1228" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a><a id="1230" class="Symbol">)</a>
<a id="1232" class="Keyword">open</a> <a id="1237" class="Keyword">import</a> <a id="1244" href="Cubical.Relation.Binary.html" class="Module">Cubical.Relation.Binary</a>
<a id="1268" class="Keyword">open</a> <a id="1273" href="Cubical.Relation.Binary.Base.html#1455" class="Module">BinaryRelation</a>
</pre>
<p>以下是我们按照标准库风格额外编写的前置模块. 这些模块主要涉及经典逻辑和集合论的基本概念. 我们预设读者对这些概念有深入的理解, 因此不会再逐一进行解释.</p>
<pre class="Agda"><a id="1380" class="Keyword">open</a> <a id="1385" class="Keyword">import</a> <a id="1392" href="CubicalExt.Axiom.Choice.html" class="Module">CubicalExt.Axiom.Choice</a>
<a id="1416" class="Keyword">open</a> <a id="1421" class="Keyword">import</a> <a id="1428" href="CubicalExt.Axiom.ExcludedMiddle.html" class="Module">CubicalExt.Axiom.ExcludedMiddle</a>
<a id="1460" class="Keyword">open</a> <a id="1465" class="Keyword">import</a> <a id="1472" href="CubicalExt.Foundations.Powerset%252A.html" class="Module">CubicalExt.Foundations.Powerset*</a> <a id="1505" class="Keyword">hiding</a> <a id="1512" class="Symbol">(</a><a id="1513" href="CubicalExt.Foundations.Powerset%252A.html#1686" class="Function">U</a><a id="1514" class="Symbol">)</a>
<a id="1516" class="Keyword">open</a> <a id="1521" class="Keyword">import</a> <a id="1528" href="CubicalExt.Foundations.Function.html" class="Module">CubicalExt.Foundations.Function</a> <a id="1560" class="Keyword">using</a> <a id="1566" class="Symbol">(</a><a id="1567" href="Cubical.Foundations.Function.html#653" class="Function Operator">_∘_</a><a id="1570" class="Symbol">;</a> <a id="1572" href="Cubical.Foundations.Function.html#527" class="Function Operator">_$_</a><a id="1575" class="Symbol">;</a> <a id="1577" href="CubicalExt.Foundations.Function.html#1005" class="Function">it</a><a id="1579" class="Symbol">)</a>
<a id="1581" class="Keyword">open</a> <a id="1586" class="Keyword">import</a> <a id="1593" href="CubicalExt.Functions.Logic.html" class="Module">CubicalExt.Functions.Logic</a> <a id="1620" class="Keyword">using</a> <a id="1626" class="Symbol">(</a><a id="1627" href="Cubical.Functions.Logic.html#1583" class="Function Operator">∥_∥ₚ</a><a id="1631" class="Symbol">;</a> <a id="1633" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">_∧_</a><a id="1636" class="Symbol">;</a> <a id="1638" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">_∨_</a><a id="1641" class="Symbol">;</a> <a id="1643" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a><a id="1646" class="Symbol">;</a> <a id="1648" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a><a id="1651" class="Symbol">;</a> <a id="1653" href="CubicalExt.Functions.Logic.html#721" class="Function">∨-elimˡ</a><a id="1660" class="Symbol">;</a> <a id="1662" href="CubicalExt.Functions.Logic.html#849" class="Function">∨-elimʳ</a><a id="1669" class="Symbol">)</a>
</pre>
<p>如果在后续的内容中出现了以下列出的变量, 但没有提前进行声明, 请理解为它们已作为隐式参数被引入，并具备以下规定的类型.</p>
<pre class="Agda"><a id="1746" class="Keyword">private</a> <a id="1754" class="Keyword">variable</a>
  <a id="1765" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a> <a id="1767" href="CubicalExt.Logic.Zorn.html#1767" class="Generalizable">u</a> <a id="1769" href="CubicalExt.Logic.Zorn.html#1769" class="Generalizable">r</a> <a id="1771" class="Symbol">:</a> <a id="1773" href="Agda.Primitive.html#591" class="Postulate">Level</a>
  <a id="1781" href="CubicalExt.Logic.Zorn.html#1781" class="Generalizable">U</a> <a id="1783" class="Symbol">:</a> <a id="1785" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="1790" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a>
  <a id="1794" href="CubicalExt.Logic.Zorn.html#1794" class="Generalizable">A</a> <a id="1796" class="Symbol">:</a> <a id="1798" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="1800" href="CubicalExt.Logic.Zorn.html#1781" class="Generalizable">U</a> <a id="1802" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a>
</pre>
<p>其中 <code>Level</code> 是宇宙等级, <code>𝒫 U ℓ</code> 表示 <code>U</code> 的位于 <code>ℓ</code> 宇宙的幂集. 在后文中我们将假设排中律, 这将导致命题宇宙坍塌到一层. 从而幂集将不再有宇宙等级的区分, 使其更接近于传统意义上的幂集.</p>
<h2 id="序理论">序理论</h2>
<p>佐恩引理的表述需要序理论的基本概念. 我们将在本节中对这些概念进行简要的回顾. 给定类型 <code>U</code> 及其上的二元关系 <code>R</code>.</p>
<pre class="Agda"><a id="2000" class="Keyword">module</a> <a id="Order"></a><a id="2007" href="CubicalExt.Logic.Zorn.html#2007" class="Module">Order</a> <a id="2013" class="Symbol">{</a><a id="2014" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2016" class="Symbol">:</a> <a id="2018" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2023" href="CubicalExt.Logic.Zorn.html#1767" class="Generalizable">u</a><a id="2024" class="Symbol">}</a> <a id="2026" class="Symbol">(</a><a id="2027" href="CubicalExt.Logic.Zorn.html#2027" class="Bound">R</a> <a id="2029" class="Symbol">:</a> <a id="2031" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="2035" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2037" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2039" href="CubicalExt.Logic.Zorn.html#1769" class="Generalizable">r</a><a id="2040" class="Symbol">)</a> <a id="2042" class="Keyword">where</a>
</pre>
<h3 id="偏序">偏序</h3>
<p>如果 <code>R</code> 取值到命题, 并且满足自反, 反对称和传递性, 则称 <code>R</code> 是偏序 (partial order).</p>
<pre class="Agda">  <a id="Order.isPo"></a><a id="2131" href="CubicalExt.Logic.Zorn.html#2131" class="Function">isPo</a> <a id="2136" class="Symbol">:</a> <a id="2138" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2143" class="Symbol">_</a>
  <a id="2147" href="CubicalExt.Logic.Zorn.html#2131" class="Function">isPo</a> <a id="2152" class="Symbol">=</a> <a id="2154" href="Cubical.Relation.Binary.Base.html#2245" class="Function">isPropValued</a> <a id="2167" href="CubicalExt.Logic.Zorn.html#2027" class="Bound">R</a> <a id="2169" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2171" href="Cubical.Relation.Binary.Base.html#1523" class="Function">isRefl</a> <a id="2178" href="CubicalExt.Logic.Zorn.html#2027" class="Bound">R</a> <a id="2180" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2182" href="Cubical.Relation.Binary.Base.html#1645" class="Function">isAntisym</a> <a id="2192" href="CubicalExt.Logic.Zorn.html#2027" class="Bound">R</a> <a id="2194" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2196" href="Cubical.Relation.Binary.Base.html#1726" class="Function">isTrans</a> <a id="2204" href="CubicalExt.Logic.Zorn.html#2027" class="Bound">R</a>
</pre>
<p>如果 <code>R</code> 是偏序且 <code>U</code> 是集合, 则称 <code>U</code> 为偏序集.</p>
<pre class="Agda">  <a id="Order.isPoset"></a><a id="2256" href="CubicalExt.Logic.Zorn.html#2256" class="Function">isPoset</a> <a id="2264" class="Symbol">:</a> <a id="2266" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2271" class="Symbol">_</a>
  <a id="2275" href="CubicalExt.Logic.Zorn.html#2256" class="Function">isPoset</a> <a id="2283" class="Symbol">=</a> <a id="2285" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="2291" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2293" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2295" href="CubicalExt.Logic.Zorn.html#2131" class="Function">isPo</a>
</pre>
<h3 id="无界">无界</h3>
<p>我们又用中缀符号 <code>≤</code> 表示 <code>R</code> 关系.</p>
<pre class="Agda">  <a id="2348" class="Keyword">private</a> <a id="Order._≤_"></a><a id="2356" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">_≤_</a> <a id="2360" class="Symbol">=</a> <a id="2362" href="CubicalExt.Logic.Zorn.html#2027" class="Bound">R</a>
</pre>
<p>我们说 <code>U</code> 在 <code>R</code> 关系下是无界的, 当且仅当从任意 <code>x : U</code> 都能得到一个 <code>y : U</code> 严格大于 <code>x</code>.</p>
<pre class="Agda">  <a id="Order.unbound"></a><a id="2444" href="CubicalExt.Logic.Zorn.html#2444" class="Function">unbound</a> <a id="2452" class="Symbol">:</a> <a id="2454" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2459" class="Symbol">_</a>
  <a id="2463" href="CubicalExt.Logic.Zorn.html#2444" class="Function">unbound</a> <a id="2471" class="Symbol">=</a> <a id="2473" class="Symbol">∀</a> <a id="2475" href="CubicalExt.Logic.Zorn.html#2475" class="Bound">x</a> <a id="2477" class="Symbol">→</a> <a id="2479" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="2482" href="CubicalExt.Logic.Zorn.html#2482" class="Bound">y</a> <a id="2484" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="2486" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2488" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="2490" href="CubicalExt.Logic.Zorn.html#2475" class="Bound">x</a> <a id="2492" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="2494" href="CubicalExt.Logic.Zorn.html#2482" class="Bound">y</a> <a id="2496" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2498" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="2500" href="CubicalExt.Logic.Zorn.html#2475" class="Bound">x</a> <a id="2502" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2504" href="CubicalExt.Logic.Zorn.html#2482" class="Bound">y</a>
</pre>
<p>我们说 <code>U</code> 在 <code>R</code> 关系下是后继的, 当且仅当它是无界的, 且见证无界的那个 <code>y</code> 刚好比 <code>x</code> 大, 也就是说它们之间没有其他元素.</p>
<pre class="Agda">  <a id="Order.successive"></a><a id="2596" href="CubicalExt.Logic.Zorn.html#2596" class="Function">successive</a> <a id="2607" class="Symbol">:</a> <a id="2609" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2614" class="Symbol">_</a>
  <a id="2618" href="CubicalExt.Logic.Zorn.html#2596" class="Function">successive</a> <a id="2629" class="Symbol">=</a> <a id="2631" class="Symbol">∀</a> <a id="2633" href="CubicalExt.Logic.Zorn.html#2633" class="Bound">x</a> <a id="2635" class="Symbol">→</a> <a id="2637" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="2640" href="CubicalExt.Logic.Zorn.html#2640" class="Bound">y</a> <a id="2642" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="2644" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2646" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="2648" href="CubicalExt.Logic.Zorn.html#2633" class="Bound">x</a> <a id="2650" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="2652" href="CubicalExt.Logic.Zorn.html#2640" class="Bound">y</a> <a id="2654" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2656" class="Symbol">(</a><a id="2657" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="2659" href="CubicalExt.Logic.Zorn.html#2633" class="Bound">x</a> <a id="2661" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2663" href="CubicalExt.Logic.Zorn.html#2640" class="Bound">y</a><a id="2664" class="Symbol">)</a> <a id="2666" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="2668" class="Symbol">∀</a> <a id="2670" href="CubicalExt.Logic.Zorn.html#2670" class="Bound">z</a> <a id="2672" class="Symbol">→</a> <a id="2674" href="CubicalExt.Logic.Zorn.html#2633" class="Bound">x</a> <a id="2676" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="2678" href="CubicalExt.Logic.Zorn.html#2670" class="Bound">z</a> <a id="2680" class="Symbol">→</a> <a id="2682" href="CubicalExt.Logic.Zorn.html#2670" class="Bound">z</a> <a id="2684" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="2686" href="CubicalExt.Logic.Zorn.html#2640" class="Bound">y</a> <a id="2688" class="Symbol">→</a> <a id="2690" href="CubicalExt.Logic.Zorn.html#2670" class="Bound">z</a> <a id="2692" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2694" href="CubicalExt.Logic.Zorn.html#2633" class="Bound">x</a> <a id="2696" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="2698" href="CubicalExt.Logic.Zorn.html#2670" class="Bound">z</a> <a id="2700" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2702" href="CubicalExt.Logic.Zorn.html#2640" class="Bound">y</a>
</pre>
<h3 id="最大元">最大元</h3>
<p>对任意大于等于 <code>m</code> 的元素, 如果它其实都等于 <code>m</code>, 那么称 <code>m</code> 是 <code>U</code> 的最大元.</p>
<pre class="Agda">  <a id="Order.maximum"></a><a id="2780" href="CubicalExt.Logic.Zorn.html#2780" class="Function">maximum</a> <a id="2788" class="Symbol">:</a> <a id="2790" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2792" class="Symbol">→</a> <a id="2794" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2799" class="Symbol">_</a>
  <a id="2803" href="CubicalExt.Logic.Zorn.html#2780" class="Function">maximum</a> <a id="2811" href="CubicalExt.Logic.Zorn.html#2811" class="Bound">m</a> <a id="2813" class="Symbol">=</a> <a id="2815" class="Symbol">∀</a> <a id="2817" href="CubicalExt.Logic.Zorn.html#2817" class="Bound">x</a> <a id="2819" class="Symbol">→</a> <a id="2821" href="CubicalExt.Logic.Zorn.html#2811" class="Bound">m</a> <a id="2823" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="2825" href="CubicalExt.Logic.Zorn.html#2817" class="Bound">x</a> <a id="2827" class="Symbol">→</a> <a id="2829" href="CubicalExt.Logic.Zorn.html#2811" class="Bound">m</a> <a id="2831" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2833" href="CubicalExt.Logic.Zorn.html#2817" class="Bound">x</a>
</pre>
<p>注意无界与存在最大元是不相容的.</p>
<h3 id="链">链</h3>
<p>现在, 考虑 <code>U</code> 的子集 <code>A</code>, 如果其中的任意两个元素都可以比较大小, 我们就说 <code>A</code> 是链, 也叫 <code>U</code> 的全序子集.</p>
<pre class="Agda">  <a id="Order.isChain"></a><a id="2943" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="2951" class="Symbol">:</a> <a id="2953" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="2955" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="2957" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a> <a id="2959" class="Symbol">→</a> <a id="2961" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="2966" class="Symbol">_</a>
  <a id="2970" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="2978" href="CubicalExt.Logic.Zorn.html#2978" class="Bound">A</a> <a id="2980" class="Symbol">=</a> <a id="2982" class="Symbol">∀</a> <a id="2984" href="CubicalExt.Logic.Zorn.html#2984" class="Bound">x</a> <a id="2986" href="CubicalExt.Logic.Zorn.html#2986" class="Bound">y</a> <a id="2988" class="Symbol">→</a> <a id="2990" href="CubicalExt.Logic.Zorn.html#2984" class="Bound">x</a> <a id="2992" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="2994" href="CubicalExt.Logic.Zorn.html#2978" class="Bound">A</a> <a id="2996" class="Symbol">→</a> <a id="2998" href="CubicalExt.Logic.Zorn.html#2986" class="Bound">y</a> <a id="3000" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="3002" href="CubicalExt.Logic.Zorn.html#2978" class="Bound">A</a> <a id="3004" class="Symbol">→</a> <a id="3006" href="CubicalExt.Logic.Zorn.html#2984" class="Bound">x</a> <a id="3008" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="3010" href="CubicalExt.Logic.Zorn.html#2986" class="Bound">y</a> <a id="3012" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="3014" href="CubicalExt.Logic.Zorn.html#2986" class="Bound">y</a> <a id="3016" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="3018" href="CubicalExt.Logic.Zorn.html#2984" class="Bound">x</a>
</pre>
<p>注意 <code>∨</code> 是和类型 <code>⊎</code> 的命题截断, 从而保证了”某某是链”是一个命题. 后面要用到这一性质.</p>
<pre class="Agda">  <a id="Order.isPropIsChain"></a><a id="3088" href="CubicalExt.Logic.Zorn.html#3088" class="Function">isPropIsChain</a> <a id="3102" class="Symbol">:</a> <a id="3104" href="Cubical.Foundations.Prelude.html#14246" class="Function">isProp</a> <a id="3111" class="Symbol">(</a><a id="3112" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="3120" href="CubicalExt.Logic.Zorn.html#1794" class="Generalizable">A</a><a id="3121" class="Symbol">)</a>
  <a id="3125" href="CubicalExt.Logic.Zorn.html#3088" class="Function">isPropIsChain</a> <a id="3139" class="Symbol">=</a> <a id="3141" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="3150" class="Symbol">λ</a> <a id="3152" href="CubicalExt.Logic.Zorn.html#3152" class="Bound">_</a> <a id="3154" href="CubicalExt.Logic.Zorn.html#3154" class="Bound">_</a> <a id="3156" class="Symbol">→</a> <a id="3158" href="Cubical.Foundations.HLevels.html#16452" class="Function">isPropΠ2</a> <a id="3167" class="Symbol">λ</a> <a id="3169" href="CubicalExt.Logic.Zorn.html#3169" class="Bound">_</a> <a id="3171" href="CubicalExt.Logic.Zorn.html#3171" class="Bound">_</a> <a id="3173" class="Symbol">→</a> <a id="3175" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
</pre>
<h3 id="上界">上界</h3>
<p>给定 <code>A</code> 和 <code>ub : U</code>, 如果 <code>ub</code> 比 <code>A</code> 的任意元素都要大, 则称 <code>ub</code> 是 <code>A</code> 的上界. 注意上界不一定在 <code>A</code> 中.</p>
<pre class="Agda">  <a id="Order.upperBound"></a><a id="3285" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="3296" class="Symbol">:</a> <a id="3298" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="3300" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3302" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a> <a id="3304" class="Symbol">→</a> <a id="3306" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3308" class="Symbol">→</a> <a id="3310" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3315" class="Symbol">_</a>
  <a id="3319" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="3330" href="CubicalExt.Logic.Zorn.html#3330" class="Bound">A</a> <a id="3332" href="CubicalExt.Logic.Zorn.html#3332" class="Bound">ub</a> <a id="3335" class="Symbol">=</a> <a id="3337" class="Symbol">∀</a> <a id="3339" href="CubicalExt.Logic.Zorn.html#3339" class="Bound">x</a> <a id="3341" class="Symbol">→</a> <a id="3343" href="CubicalExt.Logic.Zorn.html#3339" class="Bound">x</a> <a id="3345" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="3347" href="CubicalExt.Logic.Zorn.html#3330" class="Bound">A</a> <a id="3349" class="Symbol">→</a> <a id="3351" href="CubicalExt.Logic.Zorn.html#3339" class="Bound">x</a> <a id="3353" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="3355" href="CubicalExt.Logic.Zorn.html#3332" class="Bound">ub</a>
</pre>
<p>由以上定义, “所有链都可以找到上界”表述如下.</p>
<pre class="Agda">  <a id="Order.allChainHasUb"></a><a id="3399" href="CubicalExt.Logic.Zorn.html#3399" class="Function">allChainHasUb</a> <a id="3413" class="Symbol">=</a> <a id="3415" class="Symbol">∀</a> <a id="3417" class="Symbol">{</a><a id="3418" href="CubicalExt.Logic.Zorn.html#3418" class="Bound">ℓ</a><a id="3419" class="Symbol">}</a> <a id="3421" class="Symbol">(</a><a id="3422" href="CubicalExt.Logic.Zorn.html#3422" class="Bound">A</a> <a id="3424" class="Symbol">:</a> <a id="3426" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="3428" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3430" href="CubicalExt.Logic.Zorn.html#3418" class="Bound">ℓ</a><a id="3431" class="Symbol">)</a> <a id="3433" class="Symbol">→</a> <a id="3435" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="3443" href="CubicalExt.Logic.Zorn.html#3422" class="Bound">A</a> <a id="3445" class="Symbol">→</a> <a id="3447" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3450" href="CubicalExt.Logic.Zorn.html#3450" class="Bound">ub</a> <a id="3453" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3455" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3457" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3459" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="3470" href="CubicalExt.Logic.Zorn.html#3422" class="Bound">A</a> <a id="3472" href="CubicalExt.Logic.Zorn.html#3450" class="Bound">ub</a>
</pre>
<h3 id="上确界">上确界</h3>
<p>给定 <code>A</code> 和 <code>sup : U</code>, 如果 <code>sup</code> 是 <code>A</code> 的最小上界, 则称 <code>sup</code> 是 <code>A</code> 的上确界. 注意上确界也不一定在 <code>A</code> 中.</p>
<pre class="Agda">  <a id="Order.supremum"></a><a id="3581" href="CubicalExt.Logic.Zorn.html#3581" class="Function">supremum</a> <a id="3590" class="Symbol">:</a> <a id="3592" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="3594" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3596" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a> <a id="3598" class="Symbol">→</a> <a id="3600" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3602" class="Symbol">→</a> <a id="3604" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3609" class="Symbol">_</a>
  <a id="3613" href="CubicalExt.Logic.Zorn.html#3581" class="Function">supremum</a> <a id="3622" href="CubicalExt.Logic.Zorn.html#3622" class="Bound">A</a> <a id="3624" href="CubicalExt.Logic.Zorn.html#3624" class="Bound">sup</a> <a id="3628" class="Symbol">=</a> <a id="3630" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="3641" href="CubicalExt.Logic.Zorn.html#3622" class="Bound">A</a> <a id="3643" href="CubicalExt.Logic.Zorn.html#3624" class="Bound">sup</a> <a id="3647" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="3649" class="Symbol">∀</a> <a id="3651" href="CubicalExt.Logic.Zorn.html#3651" class="Bound">ub</a> <a id="3654" class="Symbol">→</a> <a id="3656" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="3667" href="CubicalExt.Logic.Zorn.html#3622" class="Bound">A</a> <a id="3669" href="CubicalExt.Logic.Zorn.html#3651" class="Bound">ub</a> <a id="3672" class="Symbol">→</a> <a id="3674" href="CubicalExt.Logic.Zorn.html#3624" class="Bound">sup</a> <a id="3678" href="CubicalExt.Logic.Zorn.html#2356" class="Function Operator">≤</a> <a id="3680" href="CubicalExt.Logic.Zorn.html#3651" class="Bound">ub</a>
</pre>
<p>由以上定义, “所有链都可以找到上确界”表述如下.</p>
<pre class="Agda">  <a id="Order.allChainHasSup"></a><a id="3725" href="CubicalExt.Logic.Zorn.html#3725" class="Function">allChainHasSup</a> <a id="3740" class="Symbol">=</a> <a id="3742" class="Symbol">∀</a> <a id="3744" class="Symbol">{</a><a id="3745" href="CubicalExt.Logic.Zorn.html#3745" class="Bound">ℓ</a><a id="3746" class="Symbol">}</a> <a id="3748" class="Symbol">(</a><a id="3749" href="CubicalExt.Logic.Zorn.html#3749" class="Bound">A</a> <a id="3751" class="Symbol">:</a> <a id="3753" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="3755" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3757" href="CubicalExt.Logic.Zorn.html#3745" class="Bound">ℓ</a><a id="3758" class="Symbol">)</a> <a id="3760" class="Symbol">→</a> <a id="3762" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="3770" href="CubicalExt.Logic.Zorn.html#3749" class="Bound">A</a> <a id="3772" class="Symbol">→</a> <a id="3774" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="3777" href="CubicalExt.Logic.Zorn.html#3777" class="Bound">sup</a> <a id="3781" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="3783" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3785" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="3787" href="CubicalExt.Logic.Zorn.html#3581" class="Function">supremum</a> <a id="3796" href="CubicalExt.Logic.Zorn.html#3749" class="Bound">A</a> <a id="3798" href="CubicalExt.Logic.Zorn.html#3777" class="Bound">sup</a>
</pre>
<h3 id="佐恩引理的表述">佐恩引理的表述</h3>
<p>经过以上的概念铺垫, 我们现在可以正式阐述佐恩引理. 佐恩引理是说: 对任意偏序集 <code>U</code>, 如果 <code>U</code> 中所有的链都能<strong>找到</strong>上界, 那么 <code>U</code> 中<strong>存在</strong>一个最大元.</p>
<pre class="Agda">  <a id="Order.Zorn"></a><a id="3923" href="CubicalExt.Logic.Zorn.html#3923" class="Function">Zorn</a> <a id="3928" class="Symbol">=</a> <a id="3930" href="CubicalExt.Logic.Zorn.html#2256" class="Function">isPoset</a> <a id="3938" class="Symbol">→</a> <a id="3940" href="CubicalExt.Logic.Zorn.html#3399" class="Function">allChainHasUb</a> <a id="3954" class="Symbol">→</a> <a id="3956" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="3959" href="CubicalExt.Logic.Zorn.html#3959" class="Bound">m</a> <a id="3961" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="3963" href="CubicalExt.Logic.Zorn.html#2014" class="Bound">U</a> <a id="3965" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="3967" href="CubicalExt.Logic.Zorn.html#2780" class="Function">maximum</a> <a id="3975" href="CubicalExt.Logic.Zorn.html#3959" class="Bound">m</a>
</pre>
<p>需要注意的是, 我们仅将 <code>Σ</code> 的命题截断 <code>∃</code> 称为<em>存在</em>, 而对于 <code>Σ</code>, 我们会用诸如<em>找到</em>, <em>取到</em>, <em>得到</em>等表述. “存在”不一定能”取到”, 但能”取到”则一定”存在”. 我们尽量避免使用 <em>有</em> 这种模糊的说法.</p>
<p>当然, 佐恩引理的表述可以进一步强化为”对任意偏序集 <code>U</code>, 如果 <code>U</code> 中所有的链都<strong>存在</strong>上确界, 那么 <code>U</code> 中<strong>存在</strong>一个最大元”. 只需要用命题截断的 <code>rec</code>, 就可以证明前者蕴含后者. 然而, 我们习惯避免在前提中使用截断, 等到需要时再用 <code>rec</code> 得到截断版本.</p>
<p>佐恩引理的证明思路中反直觉的地方是我们并非直接考虑链本身, 而是考虑由所有链构成的集合在包含关系下构成的链.</p>
<h2 id="链集的链">链集的链</h2>
<p>现在, 假设排中律, 并给定偏序 <code>≤</code>.</p>
<pre class="Agda"><a id="4352" class="Keyword">module</a> <a id="Chain"></a><a id="4359" href="CubicalExt.Logic.Zorn.html#4359" class="Module">Chain</a> <a id="4365" class="Symbol">⦃</a> <a id="4367" href="CubicalExt.Logic.Zorn.html#4367" class="Bound">em</a> <a id="4370" class="Symbol">:</a> <a id="4372" class="Symbol">∀</a> <a id="4374" class="Symbol">{</a><a id="4375" href="CubicalExt.Logic.Zorn.html#4375" class="Bound">ℓ</a><a id="4376" class="Symbol">}</a> <a id="4378" class="Symbol">→</a> <a id="4380" href="CubicalExt.Axiom.ExcludedMiddle.html#460" class="Function">EM</a> <a id="4383" href="CubicalExt.Logic.Zorn.html#4375" class="Bound">ℓ</a> <a id="4385" class="Symbol">⦄</a> <a id="4387" class="Symbol">{</a><a id="4388" href="CubicalExt.Logic.Zorn.html#4388" class="Bound">U</a> <a id="4390" class="Symbol">:</a> <a id="4392" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="4397" href="CubicalExt.Logic.Zorn.html#1767" class="Generalizable">u</a><a id="4398" class="Symbol">}</a> <a id="4400" class="Symbol">(</a><a id="4401" href="CubicalExt.Logic.Zorn.html#4401" class="Bound Operator">_≤_</a> <a id="4405" class="Symbol">:</a> <a id="4407" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="4411" href="CubicalExt.Logic.Zorn.html#4388" class="Bound">U</a> <a id="4413" href="CubicalExt.Logic.Zorn.html#4388" class="Bound">U</a> <a id="4415" href="CubicalExt.Logic.Zorn.html#1769" class="Generalizable">r</a><a id="4416" class="Symbol">)</a> <a id="4418" class="Keyword">where</a>
  <a id="4426" class="Keyword">open</a> <a id="4431" class="Keyword">import</a> <a id="4438" href="CubicalExt.Logic.Classical.html" class="Module">CubicalExt.Logic.Classical</a>
  <a id="4467" class="Keyword">open</a> <a id="4472" class="Keyword">module</a> <a id="Chain.≤"></a><a id="4479" href="CubicalExt.Logic.Zorn.html#4479" class="Module">≤</a> <a id="4481" class="Symbol">=</a> <a id="4483" href="CubicalExt.Logic.Zorn.html#2007" class="Module">Order</a> <a id="4489" href="CubicalExt.Logic.Zorn.html#4401" class="Bound Operator">_≤_</a>
</pre>
<p>我们把 <code>U</code> 的子集 <code>A</code> 配备上链条件所得到的类型 <code>Chain</code> 叫做链集.</p>
<pre class="Agda">  <a id="Chain.Chain"></a><a id="4552" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="4558" class="Symbol">:</a> <a id="4560" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="4565" class="Symbol">_</a>
  <a id="4569" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="4575" class="Symbol">=</a> <a id="4577" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="4580" href="CubicalExt.Logic.Zorn.html#4580" class="Bound">A</a> <a id="4582" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="4584" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="4586" href="CubicalExt.Logic.Zorn.html#4388" class="Bound">U</a> <a id="4588" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a> <a id="4595" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="4597" href="CubicalExt.Logic.Zorn.html#2943" class="Function">≤.isChain</a> <a id="4607" href="CubicalExt.Logic.Zorn.html#4580" class="Bound">A</a>
</pre>
<p>可以证明 <code>Chain</code> 是集合.</p>
<pre class="Agda">  <a id="4643" href="CubicalExt.Logic.Zorn.html#4643" class="Function">_</a> <a id="4645" class="Symbol">:</a> <a id="4647" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="4653" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a>
  <a id="4661" class="Symbol">_</a> <a id="4663" class="Symbol">=</a> <a id="4665" href="Cubical.Foundations.HLevels.html#12848" class="Function">isSetΣ</a> <a id="4672" class="Symbol">(</a><a id="4673" href="Cubical.Foundations.HLevels.html#17906" class="Function">isSetΠ</a> <a id="4680" class="Symbol">λ</a> <a id="4682" href="CubicalExt.Logic.Zorn.html#4682" class="Bound">_</a> <a id="4684" class="Symbol">→</a> <a id="4686" href="Cubical.Foundations.HLevels.html#22223" class="Function">isSetHProp</a><a id="4696" class="Symbol">)</a> <a id="4698" class="Symbol">λ</a> <a id="4700" href="CubicalExt.Logic.Zorn.html#4700" class="Bound">_</a> <a id="4702" class="Symbol">→</a> <a id="4704" href="Cubical.Foundations.Prelude.html#18523" class="Function">isProp→isSet</a> <a id="4717" href="CubicalExt.Logic.Zorn.html#3088" class="Function">isPropIsChain</a>
</pre>
<h3 id="偏序-1">偏序</h3>
<p>定义链集上的二元关系 <code>⪯</code> 为链之间的包含关系.</p>
<pre class="Agda">  <a id="Chain._⪯_"></a><a id="4781" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">_⪯_</a> <a id="4785" class="Symbol">:</a> <a id="4787" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="4791" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="4797" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="4803" href="CubicalExt.Logic.Zorn.html#4397" class="Bound">u</a>
  <a id="4807" href="CubicalExt.Logic.Zorn.html#4807" class="Bound">a</a> <a id="4809" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">⪯</a> <a id="4811" href="CubicalExt.Logic.Zorn.html#4811" class="Bound">b</a> <a id="4813" class="Symbol">=</a> <a id="4815" href="CubicalExt.Logic.Zorn.html#4807" class="Bound">a</a> <a id="4817" class="Symbol">.</a><a id="4818" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="4822" href="CubicalExt.Foundations.Powerset%252A.html#2188" class="Function Operator">⊆</a> <a id="4824" href="CubicalExt.Logic.Zorn.html#4811" class="Bound">b</a> <a id="4826" class="Symbol">.</a><a id="4827" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<p>由于集合的包含关系是偏序, 所以 <code>⪯</code> 也是偏序.</p>
<pre class="Agda">  <a id="Chain.⪯-prop"></a><a id="4874" href="CubicalExt.Logic.Zorn.html#4874" class="Function">⪯-prop</a> <a id="4881" class="Symbol">:</a> <a id="4883" href="Cubical.Relation.Binary.Base.html#2245" class="Function">isPropValued</a> <a id="4896" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">_⪯_</a>
  <a id="4902" href="CubicalExt.Logic.Zorn.html#4874" class="Function">⪯-prop</a> <a id="4909" class="Symbol">_</a> <a id="4911" class="Symbol">_</a> <a id="4913" class="Symbol">=</a> <a id="4915" href="CubicalExt.Foundations.Powerset%252A.html#2250" class="Function">⊆-isProp</a> <a id="4924" class="Symbol">_</a> <a id="4926" class="Symbol">_</a>

  <a id="Chain.⪯-refl"></a><a id="4931" href="CubicalExt.Logic.Zorn.html#4931" class="Function">⪯-refl</a> <a id="4938" class="Symbol">:</a> <a id="4940" href="Cubical.Relation.Binary.Base.html#1523" class="Function">isRefl</a> <a id="4947" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">_⪯_</a>
  <a id="4953" href="CubicalExt.Logic.Zorn.html#4931" class="Function">⪯-refl</a> <a id="4960" class="Symbol">=</a> <a id="4962" href="CubicalExt.Foundations.Powerset%252A.html#2372" class="Function">⊆-refl</a> <a id="4969" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="4971" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>

  <a id="Chain.⪯-antisym"></a><a id="4978" href="CubicalExt.Logic.Zorn.html#4978" class="Function">⪯-antisym</a> <a id="4988" class="Symbol">:</a> <a id="4990" href="Cubical.Relation.Binary.Base.html#1645" class="Function">isAntisym</a> <a id="5000" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">_⪯_</a>
  <a id="5006" href="CubicalExt.Logic.Zorn.html#4978" class="Function">⪯-antisym</a> <a id="5016" class="Symbol">_</a> <a id="5018" class="Symbol">_</a> <a id="5020" href="CubicalExt.Logic.Zorn.html#5020" class="Bound">H₁</a> <a id="5023" href="CubicalExt.Logic.Zorn.html#5023" class="Bound">H₂</a> <a id="5026" class="Symbol">=</a> <a id="5028" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="5035" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5037" href="CubicalExt.Foundations.Powerset%252A.html#3143" class="Function">⊆-antisym</a> <a id="5047" class="Symbol">_</a> <a id="5049" class="Symbol">_</a> <a id="5051" href="CubicalExt.Logic.Zorn.html#5020" class="Bound">H₁</a> <a id="5054" href="CubicalExt.Logic.Zorn.html#5023" class="Bound">H₂</a> <a id="5057" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5059" href="Cubical.Foundations.Prelude.html#12953" class="Function">toPathP</a> <a id="5067" class="Symbol">(</a><a id="5068" href="CubicalExt.Logic.Zorn.html#3088" class="Function">≤.isPropIsChain</a> <a id="5084" class="Symbol">_</a> <a id="5086" class="Symbol">_)</a>

  <a id="Chain.⪯-trans"></a><a id="5092" href="CubicalExt.Logic.Zorn.html#5092" class="Function">⪯-trans</a> <a id="5100" class="Symbol">:</a> <a id="5102" href="Cubical.Relation.Binary.Base.html#1726" class="Function">isTrans</a> <a id="5110" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">_⪯_</a>
  <a id="5116" href="CubicalExt.Logic.Zorn.html#5092" class="Function">⪯-trans</a> <a id="5124" class="Symbol">_</a> <a id="5126" class="Symbol">_</a> <a id="5128" class="Symbol">_</a> <a id="5130" href="CubicalExt.Logic.Zorn.html#5130" class="Bound">H₁</a> <a id="5133" href="CubicalExt.Logic.Zorn.html#5133" class="Bound">H₂</a> <a id="5136" href="CubicalExt.Logic.Zorn.html#5136" class="Bound">x∈</a> <a id="5139" class="Symbol">=</a> <a id="5141" href="CubicalExt.Logic.Zorn.html#5133" class="Bound">H₂</a> <a id="5144" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="5146" href="CubicalExt.Logic.Zorn.html#5130" class="Bound">H₁</a> <a id="5149" href="CubicalExt.Logic.Zorn.html#5136" class="Bound">x∈</a>

  <a id="5155" class="Keyword">open</a> <a id="5160" class="Keyword">module</a> <a id="Chain.⪯"></a><a id="5167" href="CubicalExt.Logic.Zorn.html#5167" class="Module">⪯</a> <a id="5169" class="Symbol">=</a> <a id="5171" href="CubicalExt.Logic.Zorn.html#2007" class="Module">Order</a> <a id="5177" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">_⪯_</a>

  <a id="Chain.⪯-po"></a><a id="5184" href="CubicalExt.Logic.Zorn.html#5184" class="Function">⪯-po</a> <a id="5189" class="Symbol">:</a> <a id="5191" href="CubicalExt.Logic.Zorn.html#2131" class="Function">⪯.isPo</a>
  <a id="5200" href="CubicalExt.Logic.Zorn.html#5184" class="Function">⪯-po</a> <a id="5205" class="Symbol">=</a> <a id="5207" href="CubicalExt.Logic.Zorn.html#4874" class="Function">⪯-prop</a> <a id="5214" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5216" href="CubicalExt.Logic.Zorn.html#4931" class="Function">⪯-refl</a> <a id="5223" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5225" href="CubicalExt.Logic.Zorn.html#4978" class="Function">⪯-antisym</a> <a id="5235" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5237" href="CubicalExt.Logic.Zorn.html#5092" class="Function">⪯-trans</a>
</pre>
<p>现在我们有了两个偏序, 一个是 <code>U</code> 上的 <code>≤</code>, 一个是链集上的 <code>⪯</code>. 为避免混淆, 接下来我们会对相关概念加上 <code>≤</code> 或 <code>⪯</code> 前缀, 来指明该概念所涉及的偏序.</p>
<h3 id="上确界-1">上确界</h3>
<p>现在考虑链集的链. 注意, 尽管链集中的每个元素都是 ≤-链, 但这里我们说的是由链集中的元素组成的 ⪯-链.</p>
<p>对任意 ⪯-链 <code>A</code>, 我们可以找到其上确界, 只需取 <code>A</code> 中所有 ≤-链的”并”. 也就是说, 并作为一个集合, 其中的任意 <code>x</code>, 都需要存在一条 ≤-链 <code>a₁</code> 容纳它, 且 <code>a₁</code> 作为链集的一个元素 <code>a</code>, 必须在 <code>A</code> 中.</p>
<p>需要注意的是, <code>Chain</code> 的定义仅接受 <code>U</code> 的位于最低宇宙的子集, 为了使我们这里定义的并确实具有 <code>Chain</code> 类型, 需要将上述”并”<strong>调整</strong> (<code>Resize</code>) 到最低宇宙. 由于我们假设了排中律, 这是可以做到的. 关于具体的方法, 读者可以点击代码中的 <code>Resize</code> 查看其定义.</p>
<p>关于<strong>命题宇宙调整</strong> (propositional resizing), 以下摘自 GPT4:</p>
<blockquote>
<p>在类型论中，propositional resizing 是一个复杂的概念，涉及到如何处理命题的“大小”。这主要在同伦类型论（Homotopy Type Theory, HoTT）中出现。在类型论中，我们可以把命题看作类型，证明看作这些类型的元素。但是，不同的命题可能对应不同”大小”的类型。例如，存在性命题可能需要一个大的类型（比如，所有的自然数），而其他命题可能只需要一个小的类型（比如，真或假）。propositional resizing 就是允许我们在不改变命题的逻辑含义的情况下，改变它所对应的类型的大小。具体来说，如果我们有一个命题 P 对应的类型在一个大的类型中，而我们希望在一个小的类型中使用它，那么我们就可以使用 propositional resizing 来“缩小”它。在实际应用中，propositional resizing 能够帮助我们更灵活地处理命题和证明，特别是在处理那些涉及到无穷集合的问题时。</p>
</blockquote>
<pre class="Agda">  <a id="Chain.sup"></a><a id="6173" href="CubicalExt.Logic.Zorn.html#6173" class="Function">sup</a> <a id="6177" class="Symbol">:</a> <a id="6179" class="Symbol">(</a><a id="6180" href="CubicalExt.Logic.Zorn.html#6180" class="Bound">A</a> <a id="6182" class="Symbol">:</a> <a id="6184" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="6186" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="6192" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a><a id="6193" class="Symbol">)</a> <a id="6195" class="Symbol">→</a> <a id="6197" href="CubicalExt.Logic.Zorn.html#2943" class="Function">⪯.isChain</a> <a id="6207" href="CubicalExt.Logic.Zorn.html#6180" class="Bound">A</a> <a id="6209" class="Symbol">→</a> <a id="6211" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a>
  <a id="6219" href="CubicalExt.Logic.Zorn.html#6173" class="Function">sup</a> <a id="6223" href="CubicalExt.Logic.Zorn.html#6223" class="Bound">A</a> <a id="6225" href="CubicalExt.Logic.Zorn.html#6225" class="Bound">isChainA</a> <a id="6234" class="Symbol">=</a> <a id="6236" href="CubicalExt.Logic.Classical.html#1961" class="Function">Resize</a> <a id="6243" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="6245" class="Symbol">(λ</a> <a id="6248" href="CubicalExt.Logic.Zorn.html#6248" class="Bound">x</a> <a id="6250" class="Symbol">→</a> <a id="6252" class="Symbol">(</a><a id="6253" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="6256" href="CubicalExt.Logic.Zorn.html#6256" class="Bound">a</a><a id="6257" class="Symbol">@(</a><a id="6259" href="CubicalExt.Logic.Zorn.html#6259" class="Bound">a₁</a> <a id="6262" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6264" class="Symbol">_</a> <a id="6266" class="Symbol">)</a> <a id="6268" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="6270" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="6276" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="6278" href="CubicalExt.Logic.Zorn.html#6248" class="Bound">x</a> <a id="6280" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="6282" href="CubicalExt.Logic.Zorn.html#6259" class="Bound">a₁</a> <a id="6285" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="6287" href="CubicalExt.Logic.Zorn.html#6256" class="Bound">a</a> <a id="6289" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="6291" href="CubicalExt.Logic.Zorn.html#6223" class="Bound">A</a><a id="6292" class="Symbol">)</a> <a id="6294" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6296" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a><a id="6303" class="Symbol">)</a> <a id="6305" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a>
</pre>
<p>为了保证”并”具有 <code>Chain</code> 类型, 我们还需要说明它是一个 ≤-链. 根据定义, “并”中的任意元素都在某个 ≤-链中, 且该 ≤-链又在 <code>A</code> 中. 由于 <code>A</code> 是 ⪯-链, “并”中的任意两个元素都可以找到一个共同的 ≤-链容纳它, 因此它们可以比较大小, 这也就说明了”并”同样是 ≤-链.</p>
<pre class="Agda">    <a id="6480" class="Symbol">λ</a> <a id="6482" href="CubicalExt.Logic.Zorn.html#6482" class="Bound">x</a> <a id="6484" href="CubicalExt.Logic.Zorn.html#6484" class="Bound">y</a> <a id="6486" href="CubicalExt.Logic.Zorn.html#6486" class="Bound">x∈</a> <a id="6489" href="CubicalExt.Logic.Zorn.html#6489" class="Bound">y∈</a> <a id="6492" class="Symbol">→</a> <a id="6494" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="6499" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
      <a id="6513" class="Symbol">(λ{</a> <a id="6517" class="Symbol">(</a><a id="6518" href="CubicalExt.Logic.Zorn.html#6518" class="Bound">a</a> <a id="6520" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6522" href="CubicalExt.Logic.Zorn.html#6522" class="Bound">x∈a</a> <a id="6526" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6528" href="CubicalExt.Logic.Zorn.html#6528" class="Bound">a∈A</a><a id="6531" class="Symbol">)</a> <a id="6533" class="Symbol">(</a><a id="6534" href="CubicalExt.Logic.Zorn.html#6534" class="Bound">b</a> <a id="6536" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6538" href="CubicalExt.Logic.Zorn.html#6538" class="Bound">y∈b</a> <a id="6542" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6544" href="CubicalExt.Logic.Zorn.html#6544" class="Bound">b∈A</a><a id="6547" class="Symbol">)</a> <a id="6549" class="Symbol">→</a> <a id="6551" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="6555" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
        <a id="6571" class="Symbol">(λ{</a> <a id="6575" class="Symbol">(</a><a id="6576" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="6582" href="CubicalExt.Logic.Zorn.html#6582" class="Bound">a⪯b</a><a id="6585" class="Symbol">)</a> <a id="6587" class="Symbol">→</a> <a id="6589" href="CubicalExt.Logic.Zorn.html#6534" class="Bound">b</a> <a id="6591" class="Symbol">.</a><a id="6592" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="6596" href="CubicalExt.Logic.Zorn.html#6482" class="Bound">x</a> <a id="6598" href="CubicalExt.Logic.Zorn.html#6484" class="Bound">y</a> <a id="6600" class="Symbol">(</a><a id="6601" href="CubicalExt.Logic.Zorn.html#6582" class="Bound">a⪯b</a> <a id="6605" href="CubicalExt.Logic.Zorn.html#6522" class="Bound">x∈a</a><a id="6608" class="Symbol">)</a> <a id="6610" href="CubicalExt.Logic.Zorn.html#6538" class="Bound">y∈b</a>
          <a id="6624" class="Symbol">;</a> <a id="6626" class="Symbol">(</a><a id="6627" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="6633" href="CubicalExt.Logic.Zorn.html#6633" class="Bound">b⪯a</a><a id="6636" class="Symbol">)</a> <a id="6638" class="Symbol">→</a> <a id="6640" href="CubicalExt.Logic.Zorn.html#6518" class="Bound">a</a> <a id="6642" class="Symbol">.</a><a id="6643" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="6647" href="CubicalExt.Logic.Zorn.html#6482" class="Bound">x</a> <a id="6649" href="CubicalExt.Logic.Zorn.html#6484" class="Bound">y</a> <a id="6651" href="CubicalExt.Logic.Zorn.html#6522" class="Bound">x∈a</a> <a id="6655" class="Symbol">(</a><a id="6656" href="CubicalExt.Logic.Zorn.html#6633" class="Bound">b⪯a</a> <a id="6660" href="CubicalExt.Logic.Zorn.html#6538" class="Bound">y∈b</a><a id="6663" class="Symbol">)</a> <a id="6665" class="Symbol">})</a>
        <a id="6676" class="Symbol">(</a><a id="6677" href="CubicalExt.Logic.Zorn.html#6225" class="Bound">isChainA</a> <a id="6686" href="CubicalExt.Logic.Zorn.html#6518" class="Bound">a</a> <a id="6688" href="CubicalExt.Logic.Zorn.html#6534" class="Bound">b</a> <a id="6690" href="CubicalExt.Logic.Zorn.html#6528" class="Bound">a∈A</a> <a id="6694" href="CubicalExt.Logic.Zorn.html#6544" class="Bound">b∈A</a><a id="6697" class="Symbol">)})</a>
      <a id="6707" class="Symbol">(</a><a id="6708" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="6717" href="CubicalExt.Logic.Zorn.html#6486" class="Bound">x∈</a><a id="6719" class="Symbol">)</a> <a id="6721" class="Symbol">(</a><a id="6722" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="6731" href="CubicalExt.Logic.Zorn.html#6489" class="Bound">y∈</a><a id="6733" class="Symbol">)</a>
</pre>
<p>下面的代码证明上面说的”并”确实是上确界. 由集合论知识, 集族的并显然是 ⊆-序的上确界. 这里不再赘述.</p>
<pre class="Agda">  <a id="Chain.suphood"></a><a id="6806" href="CubicalExt.Logic.Zorn.html#6806" class="Function">suphood</a> <a id="6814" class="Symbol">:</a> <a id="6816" class="Symbol">(</a><a id="6817" href="CubicalExt.Logic.Zorn.html#6817" class="Bound">A</a> <a id="6819" class="Symbol">:</a> <a id="6821" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="6823" href="CubicalExt.Logic.Zorn.html#4552" class="Function">Chain</a> <a id="6829" href="CubicalExt.Logic.Zorn.html#1765" class="Generalizable">ℓ</a><a id="6830" class="Symbol">)</a> <a id="6832" class="Symbol">(</a><a id="6833" href="CubicalExt.Logic.Zorn.html#6833" class="Bound">isChainA</a> <a id="6842" class="Symbol">:</a> <a id="6844" href="CubicalExt.Logic.Zorn.html#2943" class="Function">⪯.isChain</a> <a id="6854" href="CubicalExt.Logic.Zorn.html#6817" class="Bound">A</a><a id="6855" class="Symbol">)</a> <a id="6857" class="Symbol">→</a> <a id="6859" href="CubicalExt.Logic.Zorn.html#3581" class="Function">⪯.supremum</a> <a id="6870" href="CubicalExt.Logic.Zorn.html#6817" class="Bound">A</a> <a id="6872" class="Symbol">(</a><a id="6873" href="CubicalExt.Logic.Zorn.html#6173" class="Function">sup</a> <a id="6877" href="CubicalExt.Logic.Zorn.html#6817" class="Bound">A</a> <a id="6879" href="CubicalExt.Logic.Zorn.html#6833" class="Bound">isChainA</a><a id="6887" class="Symbol">)</a>
  <a id="6891" href="CubicalExt.Logic.Zorn.html#6806" class="Function">suphood</a> <a id="6899" href="CubicalExt.Logic.Zorn.html#6899" class="Bound">A</a> <a id="6901" href="CubicalExt.Logic.Zorn.html#6901" class="Bound">isChainA</a> <a id="6910" class="Symbol">=</a> <a id="6912" class="Symbol">(λ</a> <a id="6915" class="Symbol">{</a> <a id="6917" href="CubicalExt.Logic.Zorn.html#6917" class="Bound">a</a> <a id="6919" href="CubicalExt.Logic.Zorn.html#6919" class="Bound">a∈A</a> <a id="6923" href="CubicalExt.Logic.Zorn.html#6923" class="Bound">x∈a₁</a> <a id="6928" class="Symbol">→</a> <a id="6930" href="CubicalExt.Logic.Classical.html#2032" class="Function">resize</a> <a id="6937" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="6939" href="CubicalExt.Logic.Zorn.html#6917" class="Bound">a</a> <a id="6941" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6943" href="CubicalExt.Logic.Zorn.html#6923" class="Bound">x∈a₁</a> <a id="6948" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6950" href="CubicalExt.Logic.Zorn.html#6919" class="Bound">a∈A</a> <a id="6954" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="6957" class="Symbol">})</a> <a id="6960" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a>
    <a id="6966" class="Symbol">λ</a> <a id="6968" href="CubicalExt.Logic.Zorn.html#6968" class="Bound">ub</a> <a id="6971" href="CubicalExt.Logic.Zorn.html#6971" class="Bound">ubhood</a> <a id="6978" href="CubicalExt.Logic.Zorn.html#6978" class="Bound">x∈sup</a> <a id="6984" class="Symbol">→</a> <a id="6986" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="6990" class="Symbol">(</a><a id="6991" href="CubicalExt.Foundations.Powerset%252A.html#2034" class="Function">∈-isProp</a> <a id="7000" class="Symbol">(</a><a id="7001" href="CubicalExt.Logic.Zorn.html#6968" class="Bound">ub</a> <a id="7004" class="Symbol">.</a><a id="7005" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="7008" class="Symbol">)</a> <a id="7010" class="Symbol">_)</a>
      <a id="7019" class="Symbol">(λ{</a> <a id="7023" class="Symbol">(</a><a id="7024" href="CubicalExt.Logic.Zorn.html#7024" class="Bound">a</a> <a id="7026" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7028" href="CubicalExt.Logic.Zorn.html#7028" class="Bound">x∈a₁</a> <a id="7033" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7035" href="CubicalExt.Logic.Zorn.html#7035" class="Bound">a∈A</a><a id="7038" class="Symbol">)</a> <a id="7040" class="Symbol">→</a> <a id="7042" href="CubicalExt.Logic.Zorn.html#6971" class="Bound">ubhood</a> <a id="7049" href="CubicalExt.Logic.Zorn.html#7024" class="Bound">a</a> <a id="7051" href="CubicalExt.Logic.Zorn.html#7035" class="Bound">a∈A</a> <a id="7055" href="CubicalExt.Logic.Zorn.html#7028" class="Bound">x∈a₁</a> <a id="7060" class="Symbol">})</a>
      <a id="7069" class="Symbol">(</a><a id="7070" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="7079" href="CubicalExt.Logic.Zorn.html#6978" class="Bound">x∈sup</a><a id="7084" class="Symbol">)</a>
</pre>
<p>至此, 我们证明了链集中的任意链都能找到上确界.</p>
<pre class="Agda">  <a id="Chain.⪯-allChainHasSup"></a><a id="7123" href="CubicalExt.Logic.Zorn.html#7123" class="Function">⪯-allChainHasSup</a> <a id="7140" class="Symbol">:</a> <a id="7142" href="CubicalExt.Logic.Zorn.html#3725" class="Function">⪯.allChainHasSup</a>
  <a id="7161" href="CubicalExt.Logic.Zorn.html#7123" class="Function">⪯-allChainHasSup</a> <a id="7178" href="CubicalExt.Logic.Zorn.html#7178" class="Bound">A</a> <a id="7180" href="CubicalExt.Logic.Zorn.html#7180" class="Bound">isChainA</a> <a id="7189" class="Symbol">=</a> <a id="7191" href="CubicalExt.Logic.Zorn.html#6173" class="Function">sup</a> <a id="7195" href="CubicalExt.Logic.Zorn.html#7178" class="Bound">A</a> <a id="7197" href="CubicalExt.Logic.Zorn.html#7180" class="Bound">isChainA</a> <a id="7206" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7208" href="CubicalExt.Logic.Zorn.html#6806" class="Function">suphood</a> <a id="7216" href="CubicalExt.Logic.Zorn.html#7178" class="Bound">A</a> <a id="7218" href="CubicalExt.Logic.Zorn.html#7180" class="Bound">isChainA</a>
</pre>
<h3 id="后继性">后继性</h3>
<p>接下来我们将证明一个关键的引理. 它的前两个前提与佐恩引理相同, 第三个前提则是对佐恩引理结论的否定, 我们将在最后一节使用选择公理来证明这一点. 最后, 我们将采用反证法来证明佐恩引理, 只需将下面引理的结论与上一小节所证明的事实结合起来找到矛盾即可.</p>
<p>先回到该引理的证明, 要找到给定的 <code>a : Chain</code> 的后继. 具体地, 有五个子目标: 给出后继 <code>a'</code>; 说明它小于等于 <code>a</code>; 说明它不等于 <code>a</code>; 说明 <code>a</code> 与 <code>a'</code> 之间没有其他元素.</p>
<pre class="Agda">  <a id="Chain.⪯-successvie"></a><a id="7489" href="CubicalExt.Logic.Zorn.html#7489" class="Function">⪯-successvie</a> <a id="7502" class="Symbol">:</a> <a id="7504" href="CubicalExt.Logic.Zorn.html#2256" class="Function">≤.isPoset</a> <a id="7514" class="Symbol">→</a> <a id="7516" href="CubicalExt.Logic.Zorn.html#3399" class="Function">≤.allChainHasUb</a> <a id="7532" class="Symbol">→</a> <a id="7534" href="CubicalExt.Logic.Zorn.html#2444" class="Function">≤.unbound</a> <a id="7544" class="Symbol">→</a> <a id="7546" href="CubicalExt.Logic.Zorn.html#2596" class="Function">⪯.successive</a>
  <a id="7561" href="CubicalExt.Logic.Zorn.html#7489" class="Function">⪯-successvie</a> <a id="7574" class="Symbol">(</a><a id="7575" href="CubicalExt.Logic.Zorn.html#7575" class="Bound">Uset</a> <a id="7580" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7582" href="CubicalExt.Logic.Zorn.html#7582" class="Bound">≤-po</a><a id="7586" class="Symbol">)</a> <a id="7588" href="CubicalExt.Logic.Zorn.html#7588" class="Bound">hasUb</a> <a id="7594" href="CubicalExt.Logic.Zorn.html#7594" class="Bound">unbnd</a> <a id="7600" href="CubicalExt.Logic.Zorn.html#7600" class="Bound">a</a><a id="7601" class="Symbol">@(</a><a id="7603" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a> <a id="7605" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7607" href="CubicalExt.Logic.Zorn.html#7607" class="Bound">isChainA</a><a id="7615" class="Symbol">)</a> <a id="7617" class="Symbol">=</a> <a id="7619" href="CubicalExt.Logic.Zorn.html#8842" class="Function">a&#39;</a> <a id="7622" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7624" href="CubicalExt.Logic.Classical.html#2032" class="Function">resize</a> <a id="7631" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="7633" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="7637" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7639" href="CubicalExt.Logic.Zorn.html#8956" class="Function">a≢a&#39;</a> <a id="7644" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7646" href="CubicalExt.Logic.Zorn.html#9290" class="Function">noMid</a> <a id="7652" class="Keyword">where</a>
</pre>
<p>由前提, <code>≤</code> 自反, 反对称且传递.</p>
<pre class="Agda">    <a id="7697" href="CubicalExt.Logic.Zorn.html#7697" class="Function">≤-refl</a>    <a id="7707" class="Symbol">=</a> <a id="7709" href="CubicalExt.Logic.Zorn.html#7582" class="Bound">≤-po</a> <a id="7714" class="Symbol">.</a><a id="7715" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="7719" class="Symbol">.</a><a id="7720" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="7728" href="CubicalExt.Logic.Zorn.html#7728" class="Function">≤-antisym</a> <a id="7738" class="Symbol">=</a> <a id="7740" href="CubicalExt.Logic.Zorn.html#7582" class="Bound">≤-po</a> <a id="7745" class="Symbol">.</a><a id="7746" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="7750" class="Symbol">.</a><a id="7751" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="7755" class="Symbol">.</a><a id="7756" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="7764" href="CubicalExt.Logic.Zorn.html#7764" class="Function">≤-trans</a>   <a id="7774" class="Symbol">=</a> <a id="7776" href="CubicalExt.Logic.Zorn.html#7582" class="Bound">≤-po</a> <a id="7781" class="Symbol">.</a><a id="7782" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="7786" class="Symbol">.</a><a id="7787" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="7791" class="Symbol">.</a><a id="7792" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
</pre>
<p>将 <code>a</code> 分解为 <code>U</code> 的子集 <code>A</code> 以及它是 ≤-链的证据 <code>isChainA</code>. 由于 <code>A</code> 是 ≤-链, 由前提, 它有上界 <code>ub</code>. 又 <code>U</code> ≤-无界, 所以有比 <code>ub</code> 更大的 <code>ub'</code>.</p>
<pre class="Agda">    <a id="7923" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a>        <a id="7933" class="Symbol">=</a> <a id="7935" href="CubicalExt.Logic.Zorn.html#7588" class="Bound">hasUb</a> <a id="7941" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a> <a id="7943" href="CubicalExt.Logic.Zorn.html#7607" class="Bound">isChainA</a> <a id="7952" class="Symbol">.</a><a id="7953" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="7961" href="CubicalExt.Logic.Zorn.html#7961" class="Function">ubhood</a>    <a id="7971" class="Symbol">=</a> <a id="7973" href="CubicalExt.Logic.Zorn.html#7588" class="Bound">hasUb</a> <a id="7979" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a> <a id="7981" href="CubicalExt.Logic.Zorn.html#7607" class="Bound">isChainA</a> <a id="7990" class="Symbol">.</a><a id="7991" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
    <a id="7999" href="CubicalExt.Logic.Zorn.html#7999" class="Function">ub&#39;</a>       <a id="8009" class="Symbol">=</a> <a id="8011" href="CubicalExt.Logic.Zorn.html#7594" class="Bound">unbnd</a> <a id="8017" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a> <a id="8020" class="Symbol">.</a><a id="8021" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8029" href="CubicalExt.Logic.Zorn.html#8029" class="Function">ub≤</a>       <a id="8039" class="Symbol">=</a> <a id="8041" href="CubicalExt.Logic.Zorn.html#7594" class="Bound">unbnd</a> <a id="8047" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a> <a id="8050" class="Symbol">.</a><a id="8051" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="8055" class="Symbol">.</a><a id="8056" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="8064" href="CubicalExt.Logic.Zorn.html#8064" class="Function">ub≢</a>       <a id="8074" class="Symbol">=</a> <a id="8076" href="CubicalExt.Logic.Zorn.html#7594" class="Bound">unbnd</a> <a id="8082" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a> <a id="8085" class="Symbol">.</a><a id="8086" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a><a id="8089" class="Symbol">.</a> <a id="8091" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
</pre>
<p>现在, 取 <code>A</code> 中元素与 <code>ub</code> 所组成的集合, 记作 <code>A ⨭ ub</code>, 命名为 <code>A'</code>, 并调整到最低宇宙. 注意, 这里的 <code>⨭</code> 运算要求全集 <code>U</code> 是集合.</p>
<pre class="Agda">    <a id="8202" class="Keyword">open</a> <a id="8207" href="CubicalExt.Foundations.Powerset%252A.html#4561" class="Module">SetBased</a> <a id="8216" href="CubicalExt.Logic.Zorn.html#7575" class="Bound">Uset</a> <a id="8221" class="Keyword">using</a> <a id="8227" class="Symbol">(</a><a id="8228" href="CubicalExt.Foundations.Powerset%252A.html#4802" class="Function Operator">_⨭_</a><a id="8231" class="Symbol">)</a>
    <a id="8237" href="CubicalExt.Logic.Zorn.html#8237" class="Function">A&#39;</a> <a id="8240" class="Symbol">=</a> <a id="8242" href="CubicalExt.Logic.Classical.html#1961" class="Function">Resize</a> <a id="8249" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="8251" class="Symbol">(</a><a id="8252" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a> <a id="8254" href="CubicalExt.Foundations.Powerset%252A.html#4802" class="Function Operator">⨭</a> <a id="8256" href="CubicalExt.Logic.Zorn.html#7999" class="Function">ub&#39;</a><a id="8259" class="Symbol">)</a>
</pre>
<p>由于 <code>ub'</code> 比 <code>A</code> 中元素都大, 所以把它加进 <code>A</code> 后可以与 <code>A</code> 中所有元素比出大小, 所以 <code>A'</code> 也是 ≤-链.</p>
<pre class="Agda">    <a id="8348" href="CubicalExt.Logic.Zorn.html#8348" class="Function">isChainA&#39;</a> <a id="8358" class="Symbol">:</a> <a id="8360" href="CubicalExt.Logic.Zorn.html#2943" class="Function">≤.isChain</a> <a id="8370" href="CubicalExt.Logic.Zorn.html#8237" class="Function">A&#39;</a>
    <a id="8377" href="CubicalExt.Logic.Zorn.html#8348" class="Function">isChainA&#39;</a> <a id="8387" href="CubicalExt.Logic.Zorn.html#8387" class="Bound">x</a> <a id="8389" href="CubicalExt.Logic.Zorn.html#8389" class="Bound">y</a> <a id="8391" href="CubicalExt.Logic.Zorn.html#8391" class="Bound">x∈</a> <a id="8394" href="CubicalExt.Logic.Zorn.html#8394" class="Bound">y∈</a> <a id="8397" class="Symbol">=</a> <a id="8399" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="8404" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
      <a id="8418" class="Symbol">(λ{</a> <a id="8422" class="Symbol">(</a><a id="8423" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8429" href="CubicalExt.Logic.Zorn.html#8429" class="Bound">x∈A</a><a id="8432" class="Symbol">)</a>    <a id="8437" class="Symbol">(</a><a id="8438" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8444" href="CubicalExt.Logic.Zorn.html#8444" class="Bound">y∈A</a><a id="8447" class="Symbol">)</a>    <a id="8452" class="Symbol">→</a> <a id="8454" href="CubicalExt.Logic.Zorn.html#7607" class="Bound">isChainA</a> <a id="8463" href="CubicalExt.Logic.Zorn.html#8387" class="Bound">x</a> <a id="8465" href="CubicalExt.Logic.Zorn.html#8389" class="Bound">y</a> <a id="8467" href="CubicalExt.Logic.Zorn.html#8429" class="Bound">x∈A</a> <a id="8471" href="CubicalExt.Logic.Zorn.html#8444" class="Bound">y∈A</a>
        <a id="8483" class="Symbol">;</a> <a id="8485" class="Symbol">(</a><a id="8486" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8492" href="CubicalExt.Logic.Zorn.html#8492" class="Bound">x∈A</a><a id="8495" class="Symbol">)</a>    <a id="8500" class="Symbol">(</a><a id="8501" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="8507" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="8513" class="Symbol">)</a> <a id="8515" class="Symbol">→</a> <a id="8517" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="8521" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8523" href="CubicalExt.Logic.Zorn.html#7764" class="Function">≤-trans</a> <a id="8531" href="CubicalExt.Logic.Zorn.html#8387" class="Bound">x</a> <a id="8533" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a> <a id="8536" href="CubicalExt.Logic.Zorn.html#8389" class="Bound">y</a> <a id="8538" class="Symbol">(</a><a id="8539" href="CubicalExt.Logic.Zorn.html#7961" class="Function">ubhood</a> <a id="8546" href="CubicalExt.Logic.Zorn.html#8387" class="Bound">x</a> <a id="8548" href="CubicalExt.Logic.Zorn.html#8492" class="Bound">x∈A</a><a id="8551" class="Symbol">)</a> <a id="8553" href="CubicalExt.Logic.Zorn.html#8029" class="Function">ub≤</a>
        <a id="8565" class="Symbol">;</a> <a id="8567" class="Symbol">(</a><a id="8568" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="8574" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="8580" class="Symbol">)</a> <a id="8582" class="Symbol">(</a><a id="8583" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="8589" href="CubicalExt.Logic.Zorn.html#8589" class="Bound">y∈A</a><a id="8592" class="Symbol">)</a>    <a id="8597" class="Symbol">→</a> <a id="8599" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="8603" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8605" href="CubicalExt.Logic.Zorn.html#7764" class="Function">≤-trans</a> <a id="8613" href="CubicalExt.Logic.Zorn.html#8389" class="Bound">y</a> <a id="8615" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a> <a id="8618" href="CubicalExt.Logic.Zorn.html#8387" class="Bound">x</a> <a id="8620" class="Symbol">(</a><a id="8621" href="CubicalExt.Logic.Zorn.html#7961" class="Function">ubhood</a> <a id="8628" href="CubicalExt.Logic.Zorn.html#8389" class="Bound">y</a> <a id="8630" href="CubicalExt.Logic.Zorn.html#8589" class="Bound">y∈A</a><a id="8633" class="Symbol">)</a> <a id="8635" href="CubicalExt.Logic.Zorn.html#8029" class="Function">ub≤</a>
        <a id="8647" class="Symbol">;</a> <a id="8649" class="Symbol">(</a><a id="8650" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="8656" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="8662" class="Symbol">)</a> <a id="8664" class="Symbol">(</a><a id="8665" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="8671" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="8677" class="Symbol">)</a> <a id="8679" class="Symbol">→</a> <a id="8681" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="8685" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="8687" href="CubicalExt.Logic.Zorn.html#7697" class="Function">≤-refl</a> <a id="8694" href="CubicalExt.Logic.Zorn.html#8387" class="Bound">x</a> <a id="8696" class="Symbol">})</a>
      <a id="8705" class="Symbol">(</a><a id="8706" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="8715" href="CubicalExt.Logic.Zorn.html#8391" class="Bound">x∈</a><a id="8717" class="Symbol">)</a> <a id="8719" class="Symbol">(</a><a id="8720" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="8729" href="CubicalExt.Logic.Zorn.html#8394" class="Bound">y∈</a><a id="8731" class="Symbol">)</a>
</pre>
<p><code>A'</code> 配备上它是 ≤-链的证据 <code>isChainA'</code> 得到 <code>a' : Chain</code>. 我们宣称 <code>a'</code> 就是所需后继. 显然 <code>A ⊆ A'</code>, 所以 <code>a ⪯ a'</code>.</p>
<pre class="Agda">    <a id="8842" href="CubicalExt.Logic.Zorn.html#8842" class="Function">a&#39;</a> <a id="8845" class="Symbol">=</a> <a id="8847" href="CubicalExt.Logic.Zorn.html#8237" class="Function">A&#39;</a> <a id="8850" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="8852" href="CubicalExt.Logic.Zorn.html#8348" class="Function">isChainA&#39;</a>
</pre>
<p>由于 <code>ub'</code> 比 <code>A</code> 中所有元素都大, 所以它不在 <code>A</code> 中, 所以 <code>A</code> 与 <code>A'</code> 不同, 这就说明了 <code>a</code> 与 <code>a'</code> 不同.</p>
<pre class="Agda">    <a id="8956" href="CubicalExt.Logic.Zorn.html#8956" class="Function">a≢a&#39;</a> <a id="8961" class="Symbol">:</a> <a id="8963" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="8965" href="CubicalExt.Logic.Zorn.html#7600" class="Bound">a</a> <a id="8967" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="8969" href="CubicalExt.Logic.Zorn.html#8842" class="Function">a&#39;</a>
    <a id="8976" href="CubicalExt.Logic.Zorn.html#8956" class="Function">a≢a&#39;</a> <a id="8981" href="CubicalExt.Logic.Zorn.html#8981" class="Bound">eq</a> <a id="8984" class="Symbol">=</a> <a id="8986" class="Keyword">let</a> <a id="8990" href="CubicalExt.Logic.Zorn.html#8990" class="Bound">eq</a> <a id="8993" class="Symbol">=</a> <a id="8995" href="Cubical.Data.Sigma.Properties.html#2119" class="Function">PathPΣ</a> <a id="9002" href="CubicalExt.Logic.Zorn.html#8981" class="Bound">eq</a> <a id="9005" class="Symbol">.</a><a id="9006" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="9010" class="Keyword">in</a>
      <a id="9019" href="CubicalExt.Logic.Zorn.html#8064" class="Function">ub≢</a> <a id="9023" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9025" href="CubicalExt.Logic.Zorn.html#7728" class="Function">≤-antisym</a> <a id="9035" href="CubicalExt.Logic.Zorn.html#7923" class="Function">ub</a> <a id="9038" href="CubicalExt.Logic.Zorn.html#7999" class="Function">ub&#39;</a> <a id="9042" href="CubicalExt.Logic.Zorn.html#8029" class="Function">ub≤</a> <a id="9046" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9048" href="CubicalExt.Logic.Zorn.html#7961" class="Function">ubhood</a> <a id="9055" href="CubicalExt.Logic.Zorn.html#7999" class="Function">ub&#39;</a> <a id="9059" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a>
      <a id="9067" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="9073" class="Symbol">(</a><a id="9074" href="CubicalExt.Logic.Zorn.html#7999" class="Function">ub&#39;</a> <a id="9078" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈_</a><a id="9080" class="Symbol">)</a> <a id="9082" class="Symbol">(</a><a id="9083" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="9087" href="CubicalExt.Logic.Zorn.html#8990" class="Bound">eq</a><a id="9089" class="Symbol">)</a> <a id="9091" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9093" href="CubicalExt.Logic.Classical.html#2032" class="Function">resize</a> <a id="9100" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9102" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="9106" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a>
</pre>
<p>最后, 我们要说明 <code>a</code> 与 <code>a'</code> 之间没有其他元素. 给定 <code>b</code> 在 <code>a</code> 与 <code>a'</code> 之间, 我们说明 <code>b</code> 要么等于 <code>a</code>, 要么等于 <code>a'</code>. 将 <code>b</code> 分解为 <code>U</code> 的子集 <code>B</code> 以及它是 ≤-链的证据 <code>isChainB</code>. 现在, 用排中律讨论 <code>ub'</code> 是否在 <code>B</code> 中.</p>
<pre class="Agda">    <a id="9290" href="CubicalExt.Logic.Zorn.html#9290" class="Function">noMid</a> <a id="9296" class="Symbol">:</a> <a id="9298" class="Symbol">∀</a> <a id="9300" href="CubicalExt.Logic.Zorn.html#9300" class="Bound">b</a> <a id="9302" class="Symbol">→</a> <a id="9304" href="CubicalExt.Logic.Zorn.html#7600" class="Bound">a</a> <a id="9306" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">⪯</a> <a id="9308" href="CubicalExt.Logic.Zorn.html#9300" class="Bound">b</a> <a id="9310" class="Symbol">→</a> <a id="9312" href="CubicalExt.Logic.Zorn.html#9300" class="Bound">b</a> <a id="9314" href="CubicalExt.Logic.Zorn.html#4781" class="Function Operator">⪯</a> <a id="9316" href="CubicalExt.Logic.Zorn.html#8842" class="Function">a&#39;</a> <a id="9319" class="Symbol">→</a> <a id="9321" href="CubicalExt.Logic.Zorn.html#9300" class="Bound">b</a> <a id="9323" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9325" href="CubicalExt.Logic.Zorn.html#7600" class="Bound">a</a> <a id="9327" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="9329" href="CubicalExt.Logic.Zorn.html#9300" class="Bound">b</a> <a id="9331" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="9333" href="CubicalExt.Logic.Zorn.html#8842" class="Function">a&#39;</a>
    <a id="9340" href="CubicalExt.Logic.Zorn.html#9290" class="Function">noMid</a> <a id="9346" href="CubicalExt.Logic.Zorn.html#9346" class="Bound">b</a><a id="9347" class="Symbol">@(</a><a id="9349" href="CubicalExt.Logic.Zorn.html#9349" class="Bound">B</a> <a id="9351" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9353" href="CubicalExt.Logic.Zorn.html#9353" class="Bound">isChainB</a><a id="9361" class="Symbol">)</a> <a id="9363" href="CubicalExt.Logic.Zorn.html#9363" class="Bound">A⊆B</a> <a id="9367" href="CubicalExt.Logic.Zorn.html#9367" class="Bound">B⊆A&#39;</a> <a id="9372" class="Keyword">with</a> <a id="9377" href="CubicalExt.Logic.Zorn.html#4367" class="Bound">em</a> <a id="9380" class="Symbol">⦃</a> <a id="9382" href="CubicalExt.Foundations.Powerset%252A.html#2034" class="Function">∈-isProp</a> <a id="9391" href="CubicalExt.Logic.Zorn.html#9349" class="Bound">B</a> <a id="9393" href="CubicalExt.Logic.Zorn.html#7999" class="Function">ub&#39;</a> <a id="9397" class="Symbol">_</a> <a id="9399" class="Symbol">_</a> <a id="9401" class="Symbol">⦄</a>
</pre>
<ul>
<li>若 <code>ub' ∈ B</code>, 我们证 <code>b ≡ a'</code>, 只需证 <code>B ≡ A'</code>, 至于它们的 <code>isChain</code> 证据, 由于是命题, 必然相等. 我们用 <code>⊆</code> 的反自反性证明 <code>B ≡ A'</code>. 已知 <code>B ⊆ A'</code> 是前提, 只需证 <code>A' ⊆ B</code>. <code>A'</code> 中的元素要么是 <code>A</code> 中的元素, 要么是 <code>ub'</code>, 而 <code>A ⊆ B</code>, <code>ub' ∈ B</code>, 所以 <code>A' ⊆ B</code>.</li>
</ul>
<pre class="Agda">    <a id="9623" class="Symbol">...</a> <a id="9627" class="Symbol">|</a> <a id="9629" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="9633" href="CubicalExt.Logic.Zorn.html#9633" class="Bound">ub&#39;∈B</a> <a id="9639" class="Symbol">=</a> <a id="9641" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="9645" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9647" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="9654" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="9656" href="CubicalExt.Foundations.Powerset%252A.html#3143" class="Function">⊆-antisym</a> <a id="9666" class="Bound">B</a> <a id="9668" href="CubicalExt.Logic.Zorn.html#8237" class="Function">A&#39;</a> <a id="9671" class="Bound">B⊆A&#39;</a> <a id="9676" href="CubicalExt.Logic.Zorn.html#9733" class="Function">A&#39;⊆B</a> <a id="9681" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9683" href="Cubical.Foundations.Prelude.html#12953" class="Function">toPathP</a> <a id="9691" class="Symbol">(</a><a id="9692" href="CubicalExt.Logic.Zorn.html#3088" class="Function">≤.isPropIsChain</a> <a id="9708" class="Symbol">_</a> <a id="9710" href="CubicalExt.Logic.Zorn.html#8348" class="Function">isChainA&#39;</a><a id="9719" class="Symbol">)</a>
      <a id="9727" class="Keyword">where</a> <a id="9733" href="CubicalExt.Logic.Zorn.html#9733" class="Function">A&#39;⊆B</a> <a id="9738" class="Symbol">:</a> <a id="9740" href="CubicalExt.Logic.Zorn.html#8237" class="Function">A&#39;</a> <a id="9743" href="CubicalExt.Foundations.Powerset%252A.html#2188" class="Function Operator">⊆</a> <a id="9745" class="Bound">B</a>
            <a id="9759" href="CubicalExt.Logic.Zorn.html#9733" class="Function">A&#39;⊆B</a> <a id="9764" href="CubicalExt.Logic.Zorn.html#9764" class="Bound">x∈A&#39;</a> <a id="9769" class="Symbol">=</a> <a id="9771" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="9775" class="Symbol">(</a><a id="9776" href="CubicalExt.Foundations.Powerset%252A.html#2034" class="Function">∈-isProp</a> <a id="9785" class="Bound">B</a> <a id="9787" class="Symbol">_)</a>
              <a id="9804" class="Symbol">(λ{</a> <a id="9808" class="Symbol">(</a><a id="9809" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="9815" href="CubicalExt.Logic.Zorn.html#9815" class="Bound">x∈A</a><a id="9818" class="Symbol">)</a>    <a id="9823" class="Symbol">→</a> <a id="9825" class="Bound">A⊆B</a> <a id="9829" href="CubicalExt.Logic.Zorn.html#9815" class="Bound">x∈A</a>
                <a id="9849" class="Symbol">;</a> <a id="9851" class="Symbol">(</a><a id="9852" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="9858" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="9864" class="Symbol">)</a> <a id="9866" class="Symbol">→</a> <a id="9868" href="CubicalExt.Logic.Zorn.html#9633" class="Bound">ub&#39;∈B</a> <a id="9874" class="Symbol">})</a>
              <a id="9891" class="Symbol">(</a><a id="9892" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="9901" href="CubicalExt.Logic.Zorn.html#9764" class="Bound">x∈A&#39;</a><a id="9905" class="Symbol">)</a>
</pre>
<ul>
<li>若 <code>ub' ∉ B</code>, 我们证 <code>b ≡ a</code>, 只需证 <code>B ≡ A</code>. 同样用 <code>⊆</code> 的反自反性, 已知 <code>A ⊆ B</code> 是前提, 只需证 <code>B ⊆ A</code>. 由于 <code>B ⊆ A'</code>, <code>A'</code> 只比 <code>A</code> 多了一个元素 <code>ub'</code>, 而 <code>ub' ∉ B</code>, 所以 <code>B ⊆ A</code>.</li>
</ul>
<pre class="Agda">    <a id="10074" class="Symbol">...</a> <a id="10078" class="Symbol">|</a> <a id="10080" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a>  <a id="10084" href="CubicalExt.Logic.Zorn.html#10084" class="Bound">ub&#39;∉B</a> <a id="10090" class="Symbol">=</a> <a id="10092" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="10096" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10098" href="Cubical.Data.Sigma.Properties.html#1955" class="Function">ΣPathP</a> <a id="10105" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10107" href="CubicalExt.Foundations.Powerset%252A.html#3143" class="Function">⊆-antisym</a> <a id="10117" class="Bound">B</a> <a id="10119" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a> <a id="10121" href="CubicalExt.Logic.Zorn.html#10180" class="Function">B⊆A</a> <a id="10125" class="Bound">A⊆B</a> <a id="10129" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10131" href="Cubical.Foundations.Prelude.html#12953" class="Function">toPathP</a> <a id="10139" class="Symbol">(</a><a id="10140" href="CubicalExt.Logic.Zorn.html#3088" class="Function">≤.isPropIsChain</a> <a id="10156" class="Symbol">_</a> <a id="10158" href="CubicalExt.Logic.Zorn.html#7607" class="Bound">isChainA</a><a id="10166" class="Symbol">)</a>
      <a id="10174" class="Keyword">where</a> <a id="10180" href="CubicalExt.Logic.Zorn.html#10180" class="Function">B⊆A</a> <a id="10184" class="Symbol">:</a> <a id="10186" class="Bound">B</a> <a id="10188" href="CubicalExt.Foundations.Powerset%252A.html#2188" class="Function Operator">⊆</a> <a id="10190" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a>
            <a id="10204" href="CubicalExt.Logic.Zorn.html#10180" class="Function">B⊆A</a> <a id="10208" href="CubicalExt.Logic.Zorn.html#10208" class="Bound">x∈B</a> <a id="10212" class="Symbol">=</a> <a id="10214" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="10218" class="Symbol">(</a><a id="10219" href="CubicalExt.Foundations.Powerset%252A.html#2034" class="Function">∈-isProp</a> <a id="10228" href="CubicalExt.Logic.Zorn.html#7603" class="Bound">A</a> <a id="10230" class="Symbol">_)</a>
              <a id="10247" class="Symbol">(λ{</a> <a id="10251" class="Symbol">(</a><a id="10252" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="10258" href="CubicalExt.Logic.Zorn.html#10258" class="Bound">x∈A</a><a id="10261" class="Symbol">)</a>    <a id="10266" class="Symbol">→</a> <a id="10268" href="CubicalExt.Logic.Zorn.html#10258" class="Bound">x∈A</a>
                <a id="10288" class="Symbol">;</a> <a id="10290" class="Symbol">(</a><a id="10291" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="10297" href="Agda.Builtin.Cubical.Id.html#343" class="InductiveConstructor">reflId</a><a id="10303" class="Symbol">)</a> <a id="10305" class="Symbol">→</a> <a id="10307" href="Cubical.Data.Empty.Base.html#187" class="Function">⊥.rec</a> <a id="10313" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="10315" href="CubicalExt.Logic.Zorn.html#10084" class="Bound">ub&#39;∉B</a> <a id="10321" href="CubicalExt.Logic.Zorn.html#10208" class="Bound">x∈B</a> <a id="10325" class="Symbol">})</a>
              <a id="10342" class="Symbol">(</a><a id="10343" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="10352" class="Symbol">(</a><a id="10353" class="Bound">B⊆A&#39;</a> <a id="10358" href="CubicalExt.Logic.Zorn.html#10208" class="Bound">x∈B</a><a id="10361" class="Symbol">))</a>
</pre>
<p>至此, 我们证明了某个序在一定条件下同时满足 “任意链都能取上确界” 与 “任意元素都取后继”. 我们将证明, 这实际上是矛盾的.</p>
<h2 id="构造矛盾">构造矛盾</h2>
<p>假设排中律, 给定偏序 <code>≤</code>, 假设其任意链都能取上确界, 且任意元素都取后继.</p>
<pre class="Agda"><a id="10496" class="Keyword">module</a> <a id="Contra"></a><a id="10503" href="CubicalExt.Logic.Zorn.html#10503" class="Module">Contra</a> <a id="10510" class="Symbol">⦃</a> <a id="10512" href="CubicalExt.Logic.Zorn.html#10512" class="Bound">em</a> <a id="10515" class="Symbol">:</a> <a id="10517" class="Symbol">∀</a> <a id="10519" class="Symbol">{</a><a id="10520" href="CubicalExt.Logic.Zorn.html#10520" class="Bound">ℓ</a><a id="10521" class="Symbol">}</a> <a id="10523" class="Symbol">→</a> <a id="10525" href="CubicalExt.Axiom.ExcludedMiddle.html#460" class="Function">EM</a> <a id="10528" href="CubicalExt.Logic.Zorn.html#10520" class="Bound">ℓ</a> <a id="10530" class="Symbol">⦄</a> <a id="10532" class="Symbol">{</a><a id="10533" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="10535" class="Symbol">:</a> <a id="10537" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="10542" href="CubicalExt.Logic.Zorn.html#1767" class="Generalizable">u</a><a id="10543" class="Symbol">}</a> <a id="10545" class="Symbol">{</a><a id="10546" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">_≤_</a> <a id="10550" class="Symbol">:</a> <a id="10552" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="10556" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="10558" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="10560" href="CubicalExt.Logic.Zorn.html#1769" class="Generalizable">r</a><a id="10561" class="Symbol">}</a>
  <a id="10565" class="Symbol">(</a><a id="10566" href="CubicalExt.Logic.Zorn.html#10566" class="Bound">≤-po</a> <a id="10571" class="Symbol">:</a> <a id="10573" href="CubicalExt.Logic.Zorn.html#2131" class="Function">Order.isPo</a> <a id="10584" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">_≤_</a><a id="10587" class="Symbol">)</a> <a id="10589" class="Symbol">(</a><a id="10590" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="10597" class="Symbol">:</a> <a id="10599" href="CubicalExt.Logic.Zorn.html#3725" class="Function">Order.allChainHasSup</a> <a id="10620" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">_≤_</a><a id="10623" class="Symbol">)</a> <a id="10625" class="Symbol">(</a><a id="10626" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="10633" class="Symbol">:</a> <a id="10635" href="CubicalExt.Logic.Zorn.html#2596" class="Function">Order.successive</a> <a id="10652" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">_≤_</a><a id="10655" class="Symbol">)</a> <a id="10657" class="Keyword">where</a>
  <a id="10665" class="Keyword">open</a> <a id="10670" class="Keyword">import</a> <a id="10677" href="CubicalExt.Logic.Classical.html" class="Module">CubicalExt.Logic.Classical</a>
  <a id="10706" class="Keyword">open</a> <a id="10711" href="CubicalExt.Logic.Zorn.html#2007" class="Module">Order</a> <a id="10717" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">_≤_</a>
</pre>
<p>由前提, <code>≤</code> 取值到命题, 自反, 反对称且传递.</p>
<pre class="Agda">  <a id="10765" class="Keyword">private</a>
    <a id="Contra.≤-prop"></a><a id="10777" href="CubicalExt.Logic.Zorn.html#10777" class="Function">≤-prop</a>    <a id="10787" class="Symbol">=</a> <a id="10789" href="CubicalExt.Logic.Zorn.html#10566" class="Bound">≤-po</a> <a id="10794" class="Symbol">.</a><a id="10795" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="Contra.≤-refl"></a><a id="10803" href="CubicalExt.Logic.Zorn.html#10803" class="Function">≤-refl</a>    <a id="10813" class="Symbol">=</a> <a id="10815" href="CubicalExt.Logic.Zorn.html#10566" class="Bound">≤-po</a> <a id="10820" class="Symbol">.</a><a id="10821" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="10825" class="Symbol">.</a><a id="10826" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="Contra.≤-antisym"></a><a id="10834" href="CubicalExt.Logic.Zorn.html#10834" class="Function">≤-antisym</a> <a id="10844" class="Symbol">=</a> <a id="10846" href="CubicalExt.Logic.Zorn.html#10566" class="Bound">≤-po</a> <a id="10851" class="Symbol">.</a><a id="10852" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="10856" class="Symbol">.</a><a id="10857" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="10861" class="Symbol">.</a><a id="10862" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="Contra.≤-trans"></a><a id="10870" href="CubicalExt.Logic.Zorn.html#10870" class="Function">≤-trans</a>   <a id="10880" class="Symbol">=</a> <a id="10882" href="CubicalExt.Logic.Zorn.html#10566" class="Bound">≤-po</a> <a id="10887" class="Symbol">.</a><a id="10888" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="10892" class="Symbol">.</a><a id="10893" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="10897" class="Symbol">.</a><a id="10898" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
    <a id="10906" class="Keyword">instance</a>
      <a id="Contra.≤-propImplicit"></a><a id="10921" href="CubicalExt.Logic.Zorn.html#10921" class="Function">≤-propImplicit</a> <a id="10936" class="Symbol">:</a> <a id="10938" class="Symbol">{</a><a id="10939" href="CubicalExt.Logic.Zorn.html#10939" class="Bound">x</a> <a id="10941" href="CubicalExt.Logic.Zorn.html#10941" class="Bound">y</a> <a id="10943" class="Symbol">:</a> <a id="10945" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a><a id="10946" class="Symbol">}</a> <a id="10948" class="Symbol">→</a> <a id="10950" href="CubicalExt.Axiom.ExcludedMiddle.html#375" class="Function">isPropImplicit</a> <a id="10965" class="Symbol">(</a><a id="10966" href="CubicalExt.Logic.Zorn.html#10939" class="Bound">x</a> <a id="10968" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="10970" href="CubicalExt.Logic.Zorn.html#10941" class="Bound">y</a><a id="10971" class="Symbol">)</a>
      <a id="10979" href="CubicalExt.Logic.Zorn.html#10921" class="Function">≤-propImplicit</a> <a id="10994" class="Symbol">=</a> <a id="10996" href="CubicalExt.Logic.Zorn.html#10777" class="Function">≤-prop</a> <a id="11003" class="Symbol">_</a> <a id="11005" class="Symbol">_</a> <a id="11007" class="Symbol">_</a> <a id="11009" class="Symbol">_</a>
</pre>
<h3 id="归纳构造塔">归纳构造”塔”</h3>
<p>接下来的构造在集合论中一般用序数上的超限递归实现, 在类型论中我们用归纳类型. 我们将定义 <code>U</code> 的一个谓词, 命名为 <code>Tower</code>. 我们会把它截断为 <code>U</code> 的子集, 命名为 <code>TowerSetℓ</code>, 然后再调整到最低宇宙, 命名为 <code>TowerSet</code>.</p>
<pre class="Agda">  <a id="11173" class="Keyword">data</a> <a id="Contra.Tower"></a><a id="11178" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11184" class="Symbol">:</a> <a id="11186" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="11188" class="Symbol">→</a> <a id="11190" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="11195" class="Symbol">(</a><a id="11196" href="Agda.Primitive.html#804" class="Primitive">ℓ-max</a> <a id="11202" class="Symbol">(</a><a id="11203" href="Agda.Primitive.html#774" class="Primitive">ℓ-suc</a> <a id="11209" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a><a id="11215" class="Symbol">)</a> <a id="11217" class="Symbol">(</a><a id="11218" href="Agda.Primitive.html#804" class="Primitive">ℓ-max</a> <a id="11224" href="CubicalExt.Logic.Zorn.html#10542" class="Bound">u</a> <a id="11226" href="CubicalExt.Logic.Zorn.html#10560" class="Bound">r</a><a id="11227" class="Symbol">))</a>
  <a id="Contra.TowerSetℓ"></a><a id="11232" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a> <a id="11242" class="Symbol">:</a> <a id="11244" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="11246" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="11248" class="Symbol">_</a>
  <a id="11252" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a> <a id="11262" href="CubicalExt.Logic.Zorn.html#11262" class="Bound">x</a> <a id="11264" class="Symbol">=</a> <a id="11266" href="Cubical.Functions.Logic.html#1583" class="Function Operator">∥</a> <a id="11268" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11274" href="CubicalExt.Logic.Zorn.html#11262" class="Bound">x</a> <a id="11276" href="Cubical.Functions.Logic.html#1583" class="Function Operator">∥ₚ</a>
  <a id="Contra.TowerSet"></a><a id="11281" href="CubicalExt.Logic.Zorn.html#11281" class="Function">TowerSet</a> <a id="11290" class="Symbol">:</a> <a id="11292" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="11294" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="11296" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a>
  <a id="11305" href="CubicalExt.Logic.Zorn.html#11281" class="Function">TowerSet</a> <a id="11314" class="Symbol">=</a> <a id="11316" href="CubicalExt.Logic.Classical.html#1961" class="Function">Resize</a> <a id="11323" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="11325" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a>
</pre>
<p>现在归纳定义谓词 <code>Tower</code>:</p>
<ul>
<li>对任意 <code>x</code> 满足 <code>Tower</code>, <code>x</code> 的后继也满足 <code>Tower</code>.</li>
<li>对任意 <code>U</code> 的子集 <code>A</code>, 如果它包含于 <code>TowerSetℓ</code>, 且是链, 那么它的上确界也满足 <code>Tower</code>.</li>
</ul>
<pre class="Agda">  <a id="11476" class="Keyword">data</a> <a id="11481" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11487" class="Keyword">where</a>
    <a id="Contra.Tower.includeSuc"></a><a id="11497" href="CubicalExt.Logic.Zorn.html#11497" class="InductiveConstructor">includeSuc</a> <a id="11508" class="Symbol">:</a> <a id="11510" class="Symbol">(</a><a id="11511" href="CubicalExt.Logic.Zorn.html#11511" class="Bound">x</a> <a id="11513" class="Symbol">:</a> <a id="11515" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a><a id="11516" class="Symbol">)</a> <a id="11518" class="Symbol">→</a> <a id="11520" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11526" href="CubicalExt.Logic.Zorn.html#11511" class="Bound">x</a> <a id="11528" class="Symbol">→</a> <a id="11530" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11536" class="Symbol">(</a><a id="11537" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="11544" href="CubicalExt.Logic.Zorn.html#11511" class="Bound">x</a> <a id="11546" class="Symbol">.</a><a id="11547" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="11550" class="Symbol">)</a>
    <a id="Contra.Tower.includeSup"></a><a id="11556" href="CubicalExt.Logic.Zorn.html#11556" class="InductiveConstructor">includeSup</a> <a id="11567" class="Symbol">:</a> <a id="11569" class="Symbol">(</a><a id="11570" href="CubicalExt.Logic.Zorn.html#11570" class="Bound">A</a> <a id="11572" class="Symbol">:</a> <a id="11574" href="CubicalExt.Foundations.Powerset%252A.html#1100" class="Function">𝒫</a> <a id="11576" href="CubicalExt.Logic.Zorn.html#10533" class="Bound">U</a> <a id="11578" href="Agda.Primitive.html#758" class="Primitive">ℓ-zero</a><a id="11584" class="Symbol">)</a> <a id="11586" class="Symbol">→</a> <a id="11588" class="Symbol">(</a><a id="11589" href="CubicalExt.Logic.Zorn.html#11570" class="Bound">A</a> <a id="11591" href="CubicalExt.Foundations.Powerset%252A.html#2188" class="Function Operator">⊆</a> <a id="11593" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a><a id="11602" class="Symbol">)</a> <a id="11604" class="Symbol">→</a> <a id="11606" class="Symbol">(</a><a id="11607" href="CubicalExt.Logic.Zorn.html#11607" class="Bound">isChainA</a> <a id="11616" class="Symbol">:</a> <a id="11618" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="11626" href="CubicalExt.Logic.Zorn.html#11570" class="Bound">A</a><a id="11627" class="Symbol">)</a> <a id="11629" class="Symbol">→</a>
      <a id="11637" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11643" class="Symbol">(</a><a id="11644" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="11651" href="CubicalExt.Logic.Zorn.html#11570" class="Bound">A</a> <a id="11653" href="CubicalExt.Logic.Zorn.html#11607" class="Bound">isChainA</a> <a id="11662" class="Symbol">.</a><a id="11663" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="11666" class="Symbol">)</a>
</pre>
<p>注意 <code>TowerSetℓ</code> 在 <code>Tower</code> 定义完成之前就被使用了. Agda 允许这种写法, 只要满足一定条件, 这里不展开.</p>
<h3 id="塔也是链">“塔”也是链</h3>
<p>接下来, 我们将证明任意两个满足 <code>Tower</code> 的元素都可以比较大小, 命名为 <code>isChainTower</code>. 一旦其证明完成, 就可以立即证明 <code>TowerSetℓ</code> 是链, 乃至 <code>TowerSet</code> 是链.</p>
<pre class="Agda">  <a id="Contra.isChainTower"></a><a id="11873" href="CubicalExt.Logic.Zorn.html#11873" class="Function">isChainTower</a> <a id="11886" class="Symbol">:</a> <a id="11888" class="Symbol">∀</a> <a id="11890" href="CubicalExt.Logic.Zorn.html#11890" class="Bound">x</a> <a id="11892" href="CubicalExt.Logic.Zorn.html#11892" class="Bound">y</a> <a id="11894" class="Symbol">→</a> <a id="11896" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11902" href="CubicalExt.Logic.Zorn.html#11890" class="Bound">x</a> <a id="11904" class="Symbol">→</a> <a id="11906" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="11912" href="CubicalExt.Logic.Zorn.html#11892" class="Bound">y</a> <a id="11914" class="Symbol">→</a> <a id="11916" href="CubicalExt.Logic.Zorn.html#11890" class="Bound">x</a> <a id="11918" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="11920" href="CubicalExt.Logic.Zorn.html#11892" class="Bound">y</a> <a id="11922" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="11924" href="CubicalExt.Logic.Zorn.html#11892" class="Bound">y</a> <a id="11926" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="11928" href="CubicalExt.Logic.Zorn.html#11890" class="Bound">x</a>
  <a id="Contra.isChainTowerSetℓ"></a><a id="11932" href="CubicalExt.Logic.Zorn.html#11932" class="Function">isChainTowerSetℓ</a> <a id="11949" class="Symbol">:</a> <a id="11951" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="11959" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a>
  <a id="11971" href="CubicalExt.Logic.Zorn.html#11932" class="Function">isChainTowerSetℓ</a> <a id="11988" href="CubicalExt.Logic.Zorn.html#11988" class="Bound">x</a> <a id="11990" href="CubicalExt.Logic.Zorn.html#11990" class="Bound">y</a> <a id="11992" class="Symbol">=</a> <a id="11994" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="11999" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="12007" class="Symbol">(</a><a id="12008" href="CubicalExt.Logic.Zorn.html#11873" class="Function">isChainTower</a> <a id="12021" href="CubicalExt.Logic.Zorn.html#11988" class="Bound">x</a> <a id="12023" href="CubicalExt.Logic.Zorn.html#11990" class="Bound">y</a><a id="12024" class="Symbol">)</a>
  <a id="Contra.isChainTowerSet"></a><a id="12028" href="CubicalExt.Logic.Zorn.html#12028" class="Function">isChainTowerSet</a> <a id="12044" class="Symbol">:</a> <a id="12046" href="CubicalExt.Logic.Zorn.html#2943" class="Function">isChain</a> <a id="12054" href="CubicalExt.Logic.Zorn.html#11281" class="Function">TowerSet</a>
  <a id="12065" href="CubicalExt.Logic.Zorn.html#12028" class="Function">isChainTowerSet</a> <a id="12081" href="CubicalExt.Logic.Zorn.html#12081" class="Bound">x</a> <a id="12083" href="CubicalExt.Logic.Zorn.html#12083" class="Bound">y</a> <a id="12085" href="CubicalExt.Logic.Zorn.html#12085" class="Bound">x∈</a> <a id="12088" href="CubicalExt.Logic.Zorn.html#12088" class="Bound">y∈</a> <a id="12091" class="Symbol">=</a> <a id="12093" href="CubicalExt.Logic.Zorn.html#11932" class="Function">isChainTowerSetℓ</a> <a id="12110" href="CubicalExt.Logic.Zorn.html#12081" class="Bound">x</a> <a id="12112" href="CubicalExt.Logic.Zorn.html#12083" class="Bound">y</a> <a id="12114" class="Symbol">(</a><a id="12115" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="12124" href="CubicalExt.Logic.Zorn.html#12085" class="Bound">x∈</a><a id="12126" class="Symbol">)</a> <a id="12128" class="Symbol">(</a><a id="12129" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="12138" href="CubicalExt.Logic.Zorn.html#12088" class="Bound">y∈</a><a id="12140" class="Symbol">)</a>
</pre>
<p>该命题的证明需要复杂的递归, 为了使结构更清晰, 我们写成互递归 (mutual recursion).</p>
<p>我们先证明结论的一个弱化版, 作为中间引理, 命名为 <code>almostChain</code>, 其证明会递归调用 <code>isChainTower</code>. 随后, 我们完成 <code>isChainTower</code> 的证明, 其中会递归调用 <code>almostChain</code>. Agda 会保证循环论证不会通过.</p>
<p>现在, 给定满足 <code>Tower</code> 条件的 <code>y</code>. 将 <code>y</code> 的后继记作 <code>y'</code>.</p>
<pre class="Agda">  <a id="12394" class="Keyword">module</a> <a id="12401" href="CubicalExt.Logic.Zorn.html#12401" class="Module">_</a> <a id="12403" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="12405" class="Symbol">(</a><a id="12406" href="CubicalExt.Logic.Zorn.html#12406" class="Bound">y∈</a> <a id="12409" class="Symbol">:</a> <a id="12411" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="12417" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a><a id="12418" class="Symbol">)</a> <a id="12420" class="Keyword">where</a>
    <a id="12430" class="Keyword">private</a> <a id="12438" href="CubicalExt.Logic.Zorn.html#12438" class="Function">y&#39;</a> <a id="12441" class="Symbol">=</a> <a id="12443" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="12450" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="12452" class="Symbol">.</a><a id="12453" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<p><code>almostChain</code> 是说任意满足 <code>Tower</code> 条件的 <code>x</code> 要么小于等于 <code>y</code> 要么大于等于 <code>y'</code>.</p>
<pre class="Agda">    <a id="12536" href="CubicalExt.Logic.Zorn.html#12536" class="Function">almostChain</a> <a id="12548" class="Symbol">:</a> <a id="12550" class="Symbol">∀</a> <a id="12552" href="CubicalExt.Logic.Zorn.html#12552" class="Bound">x</a> <a id="12554" class="Symbol">→</a> <a id="12556" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="12562" href="CubicalExt.Logic.Zorn.html#12552" class="Bound">x</a> <a id="12564" class="Symbol">→</a> <a id="12566" href="CubicalExt.Logic.Zorn.html#12552" class="Bound">x</a> <a id="12568" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="12570" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="12572" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="12574" href="CubicalExt.Logic.Zorn.html#12438" class="Function">y&#39;</a> <a id="12577" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="12579" href="CubicalExt.Logic.Zorn.html#12552" class="Bound">x</a>
</pre>
<p>这里又需要一个互递归命题 <code>almostChain'</code>: 任意属于 <code>TowerSetℓ</code> 的 <code>x</code> 要么小于等于 <code>y</code> 要么大于等于 <code>y'</code>. 它会在后面 <code>almostChain</code> 的证明里调用, 但是我们先调用 <code>almostChain</code> 来证明它. 这个证明通过对高阶归纳类型 (HIT) 进行模式匹配完成, 具体的技术细节这里不展开.</p>
<pre class="Agda">    <a id="12775" href="CubicalExt.Logic.Zorn.html#12775" class="Function">almostChain&#39;</a> <a id="12788" class="Symbol">:</a> <a id="12790" class="Symbol">∀</a> <a id="12792" href="CubicalExt.Logic.Zorn.html#12792" class="Bound">x</a> <a id="12794" class="Symbol">→</a> <a id="12796" href="CubicalExt.Logic.Zorn.html#12792" class="Bound">x</a> <a id="12798" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="12800" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a> <a id="12810" class="Symbol">→</a> <a id="12812" href="CubicalExt.Logic.Zorn.html#12792" class="Bound">x</a> <a id="12814" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="12816" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="12818" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="12820" href="CubicalExt.Logic.Zorn.html#12438" class="Function">y&#39;</a> <a id="12823" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="12825" href="CubicalExt.Logic.Zorn.html#12792" class="Bound">x</a>
    <a id="12831" href="CubicalExt.Logic.Zorn.html#12775" class="Function">almostChain&#39;</a> <a id="12844" href="CubicalExt.Logic.Zorn.html#12844" class="Bound">x</a> <a id="12846" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="12848" href="CubicalExt.Logic.Zorn.html#12848" class="Bound">x∈</a> <a id="12851" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="12854" class="Symbol">=</a> <a id="12856" href="CubicalExt.Logic.Zorn.html#12536" class="Function">almostChain</a> <a id="12868" href="CubicalExt.Logic.Zorn.html#12844" class="Bound">x</a> <a id="12870" href="CubicalExt.Logic.Zorn.html#12848" class="Bound">x∈</a>
    <a id="12877" href="CubicalExt.Logic.Zorn.html#12775" class="Function">almostChain&#39;</a> <a id="12890" href="CubicalExt.Logic.Zorn.html#12890" class="Bound">x</a> <a id="12892" class="Symbol">(</a><a id="12893" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="12901" href="CubicalExt.Logic.Zorn.html#12901" class="Bound">x∈₁</a> <a id="12905" href="CubicalExt.Logic.Zorn.html#12905" class="Bound">x∈₂</a> <a id="12909" href="CubicalExt.Logic.Zorn.html#12909" class="Bound">i</a><a id="12910" class="Symbol">)</a> <a id="12912" class="Symbol">=</a> <a id="12914" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="12922" class="Symbol">(</a><a id="12923" href="CubicalExt.Logic.Zorn.html#12775" class="Function">almostChain&#39;</a> <a id="12936" href="CubicalExt.Logic.Zorn.html#12890" class="Bound">x</a> <a id="12938" href="CubicalExt.Logic.Zorn.html#12901" class="Bound">x∈₁</a><a id="12941" class="Symbol">)</a> <a id="12943" class="Symbol">(</a><a id="12944" href="CubicalExt.Logic.Zorn.html#12775" class="Function">almostChain&#39;</a> <a id="12957" href="CubicalExt.Logic.Zorn.html#12890" class="Bound">x</a> <a id="12959" href="CubicalExt.Logic.Zorn.html#12905" class="Bound">x∈₂</a><a id="12962" class="Symbol">)</a> <a id="12964" href="CubicalExt.Logic.Zorn.html#12909" class="Bound">i</a>
</pre>
<p>回到 <code>almostChain</code> 的证明. 由 <code>Tower</code> 的定义, 前提归纳为两种情况.</p>
<ul>
<li><p><code>x</code> (这里重命名为 <code>x'</code>) 其实是某个满足 <code>Tower</code> 的 <code>x</code> 的后继. 这种情况下我们递归调用 <code>isChainTower</code> 讨论 <code>x'</code> 与 <code>y</code> 的大小, 再递归调用 <code>almostChain</code> 讨论 <code>x</code> 与 <code>y</code> 的大小, 分三种情况.</p>
<ul>
<li><code>x ≤ y</code> 且 <code>x' ≤ y</code>. 取目标的左边即证.</li>
<li><code>x ≤ y</code> 且 <code>y ≤ x'</code>. 由于 <code>x'</code> 是 <code>x</code> 的后继, 它们之间的 <code>y</code> 要么等于 <code>x</code>, 这时目标的右边 <code>x ≤ x'</code> 成立; 要么 <code>y</code> 等于 <code>x'</code>, 这时目标的左边 <code>x ≤ x'</code> 成立.</li>
<li><code>y' ≤ x</code>. 这时由传递性有 <code>y' ≤ x'</code>, 即目标右边.</li>
</ul></li>
</ul>
<pre class="Agda">    <a id="13367" href="CubicalExt.Logic.Zorn.html#12536" class="Function">almostChain</a> <a id="13379" href="CubicalExt.Logic.Zorn.html#13379" class="Bound">x&#39;</a> <a id="13382" class="Symbol">(</a><a id="13383" href="CubicalExt.Logic.Zorn.html#11497" class="InductiveConstructor">includeSuc</a> <a id="13394" href="CubicalExt.Logic.Zorn.html#13394" class="Bound">x</a> <a id="13396" href="CubicalExt.Logic.Zorn.html#13396" class="Bound">x∈</a><a id="13398" class="Symbol">)</a> <a id="13400" class="Keyword">with</a> <a id="13405" href="CubicalExt.Logic.Zorn.html#11873" class="Function">isChainTower</a> <a id="13418" href="CubicalExt.Logic.Zorn.html#13379" class="Bound">x&#39;</a> <a id="13421" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="13423" class="Symbol">(</a><a id="13424" href="CubicalExt.Logic.Zorn.html#11497" class="InductiveConstructor">includeSuc</a> <a id="13435" href="CubicalExt.Logic.Zorn.html#13394" class="Bound">x</a> <a id="13437" href="CubicalExt.Logic.Zorn.html#13396" class="Bound">x∈</a><a id="13439" class="Symbol">)</a> <a id="13441" href="CubicalExt.Logic.Zorn.html#12406" class="Bound">y∈</a>
    <a id="13448" class="Symbol">...</a> <a id="13452" class="Symbol">|</a> <a id="13454" href="CubicalExt.Logic.Zorn.html#13454" class="Bound">IH</a> <a id="13457" class="Symbol">=</a> <a id="13459" href="Cubical.HITs.PropositionalTruncation.Properties.html#1043" class="Function">rec2</a> <a id="13464" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
      <a id="13478" class="Symbol">(λ{</a> <a id="13482" class="Symbol">(</a><a id="13483" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13489" href="CubicalExt.Logic.Zorn.html#13489" class="Bound">x≤y</a><a id="13492" class="Symbol">)</a> <a id="13494" class="Symbol">(</a><a id="13495" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13501" href="CubicalExt.Logic.Zorn.html#13501" class="Bound">x&#39;≤y</a><a id="13505" class="Symbol">)</a> <a id="13507" class="Symbol">→</a> <a id="13509" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="13513" href="CubicalExt.Logic.Zorn.html#13501" class="Bound">x&#39;≤y</a>
        <a id="13526" class="Symbol">;</a> <a id="13528" class="Symbol">(</a><a id="13529" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13535" href="CubicalExt.Logic.Zorn.html#13535" class="Bound">x≤y</a><a id="13538" class="Symbol">)</a> <a id="13540" class="Symbol">(</a><a id="13541" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="13547" href="CubicalExt.Logic.Zorn.html#13547" class="Bound">y≤x&#39;</a><a id="13551" class="Symbol">)</a> <a id="13553" class="Symbol">→</a> <a id="13555" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="13559" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
          <a id="13577" class="Symbol">(λ{</a> <a id="13581" class="Symbol">(</a><a id="13582" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="13588" href="CubicalExt.Logic.Zorn.html#13588" class="Bound">y≡x</a><a id="13591" class="Symbol">)</a>  <a id="13594" class="Symbol">→</a> <a id="13596" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="13600" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="13602" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="13608" class="Symbol">(λ</a> <a id="13611" href="CubicalExt.Logic.Zorn.html#13611" class="Bound">x</a> <a id="13613" class="Symbol">→</a> <a id="13615" class="Symbol">_</a> <a id="13617" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="13619" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="13626" href="CubicalExt.Logic.Zorn.html#13611" class="Bound">x</a> <a id="13628" class="Symbol">.</a><a id="13629" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a><a id="13632" class="Symbol">)</a> <a id="13634" href="CubicalExt.Logic.Zorn.html#13588" class="Bound">y≡x</a> <a id="13638" class="Symbol">(</a><a id="13639" href="CubicalExt.Logic.Zorn.html#10803" class="Function">≤-refl</a> <a id="13646" class="Symbol">_)</a>
            <a id="13661" class="Symbol">;</a> <a id="13663" class="Symbol">(</a><a id="13664" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="13670" href="CubicalExt.Logic.Zorn.html#13670" class="Bound">y≡x&#39;</a><a id="13674" class="Symbol">)</a> <a id="13676" class="Symbol">→</a> <a id="13678" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="13682" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="13684" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="13690" class="Symbol">(λ</a> <a id="13693" href="CubicalExt.Logic.Zorn.html#13693" class="Bound">x</a> <a id="13695" class="Symbol">→</a> <a id="13697" class="Symbol">_</a> <a id="13699" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="13701" href="CubicalExt.Logic.Zorn.html#13693" class="Bound">x</a><a id="13702" class="Symbol">)</a> <a id="13704" class="Symbol">(</a><a id="13705" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="13709" href="CubicalExt.Logic.Zorn.html#13670" class="Bound">y≡x&#39;</a><a id="13713" class="Symbol">)</a> <a id="13715" class="Symbol">(</a><a id="13716" href="CubicalExt.Logic.Zorn.html#10803" class="Function">≤-refl</a> <a id="13723" class="Symbol">_)</a> <a id="13726" class="Symbol">})</a>
          <a id="13739" class="Symbol">(</a><a id="13740" href="CubicalExt.Logic.Zorn.html#13893" class="Function">noMid</a> <a id="13746" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="13748" href="CubicalExt.Logic.Zorn.html#13535" class="Bound">x≤y</a> <a id="13752" href="CubicalExt.Logic.Zorn.html#13547" class="Bound">y≤x&#39;</a><a id="13756" class="Symbol">)</a>
        <a id="13766" class="Symbol">;</a> <a id="13768" class="Symbol">(</a><a id="13769" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="13775" href="CubicalExt.Logic.Zorn.html#13775" class="Bound">y&#39;≤x</a><a id="13779" class="Symbol">)</a> <a id="13781" class="Symbol">_</a> <a id="13783" class="Symbol">→</a> <a id="13785" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="13789" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="13791" href="CubicalExt.Logic.Zorn.html#10870" class="Function">≤-trans</a> <a id="13799" href="CubicalExt.Logic.Zorn.html#12438" class="Function">y&#39;</a> <a id="13802" class="Bound">x</a> <a id="13804" class="Bound">x&#39;</a> <a id="13807" href="CubicalExt.Logic.Zorn.html#13775" class="Bound">y&#39;≤x</a> <a id="13812" href="CubicalExt.Logic.Zorn.html#13860" class="Function">x≤x&#39;</a> <a id="13817" class="Symbol">})</a>
      <a id="13826" class="Symbol">(</a><a id="13827" href="CubicalExt.Logic.Zorn.html#12536" class="Function">almostChain</a> <a id="13839" class="Bound">x</a> <a id="13841" class="Bound">x∈</a><a id="13843" class="Symbol">)</a> <a id="13845" href="CubicalExt.Logic.Zorn.html#13454" class="Bound">IH</a> <a id="13848" class="Keyword">where</a>
      <a id="13860" href="CubicalExt.Logic.Zorn.html#13860" class="Function">x≤x&#39;</a>  <a id="13866" class="Symbol">=</a> <a id="13868" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="13875" class="Bound">x</a> <a id="13877" class="Symbol">.</a><a id="13878" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="13882" class="Symbol">.</a><a id="13883" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
      <a id="13893" href="CubicalExt.Logic.Zorn.html#13893" class="Function">noMid</a> <a id="13899" class="Symbol">=</a> <a id="13901" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="13908" class="Bound">x</a> <a id="13910" class="Symbol">.</a><a id="13911" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="13915" class="Symbol">.</a><a id="13916" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="13920" class="Symbol">.</a><a id="13921" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a>
</pre>
<ul>
<li><p><code>x</code> 其实是 <code>TowerSetℓ</code> 的子集: 链 <code>A</code> 的上确界. 我们用排中律讨论 <code>y</code> 是不是 <code>A</code> 的上界.</p>
<ul>
<li><code>y</code> 是 <code>A</code> 的上界, 那么有 <code>x ≤ y</code>, 目标左边成立.</li>
<li><code>y</code> 不是 <code>A</code> 的上界, 那么有 <code>y</code> 与 <code>A</code> 的上确界 <code>x</code> 之间存在 (这里也用了排中律) 一个元素 <code>z</code> 满足 <code>y &lt; z</code> 且 <code>z ≤ x</code>. 由传递性, <code>y' ≤ x</code>, 即目标右边成立. 注意这里需要调用 <code>almostChain'</code> 以使用 “<code>A</code> 是 <code>TowerSetℓ</code> 的子集” 这一前提.</li>
</ul></li>
</ul>
<pre class="Agda">    <a id="14222" href="CubicalExt.Logic.Zorn.html#12536" class="Function">almostChain</a> <a id="14234" href="CubicalExt.Logic.Zorn.html#14234" class="Bound">x</a> <a id="14236" class="Symbol">(</a><a id="14237" href="CubicalExt.Logic.Zorn.html#11556" class="InductiveConstructor">includeSup</a> <a id="14248" href="CubicalExt.Logic.Zorn.html#14248" class="Bound">A</a> <a id="14250" href="CubicalExt.Logic.Zorn.html#14250" class="Bound">A⊆</a> <a id="14253" href="CubicalExt.Logic.Zorn.html#14253" class="Bound">isChainA</a><a id="14261" class="Symbol">)</a> <a id="14263" class="Keyword">with</a> <a id="14268" href="CubicalExt.Logic.Zorn.html#10512" class="Bound">em</a> <a id="14271" class="Symbol">{</a><a id="14272" class="Argument">P</a> <a id="14274" class="Symbol">=</a> <a id="14276" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="14287" href="CubicalExt.Logic.Zorn.html#14248" class="Bound">A</a> <a id="14289" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a><a id="14290" class="Symbol">}</a>
    <a id="14296" class="Symbol">...</a> <a id="14300" class="Symbol">|</a> <a id="14302" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="14306" href="CubicalExt.Logic.Zorn.html#14306" class="Bound">p</a> <a id="14308" class="Symbol">=</a> <a id="14310" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="14314" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="14316" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="14323" class="Bound">A</a> <a id="14325" class="Bound">isChainA</a> <a id="14334" class="Symbol">.</a><a id="14335" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14339" class="Symbol">.</a><a id="14340" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14344" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a> <a id="14346" href="CubicalExt.Logic.Zorn.html#14306" class="Bound">p</a>
    <a id="14352" class="Symbol">...</a> <a id="14356" class="Symbol">|</a> <a id="14358" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a> <a id="14361" href="CubicalExt.Logic.Zorn.html#14361" class="Bound">¬p</a> <a id="14364" class="Symbol">=</a> <a id="14366" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="14370" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="14372" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="14376" class="Symbol">(</a><a id="14377" href="CubicalExt.Logic.Zorn.html#10777" class="Function">≤-prop</a> <a id="14384" class="Symbol">_</a> <a id="14386" class="Symbol">_)</a>
      <a id="14395" class="Symbol">(λ{</a> <a id="14399" class="Symbol">(</a><a id="14400" href="CubicalExt.Logic.Zorn.html#14400" class="Bound">z</a> <a id="14402" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14404" href="CubicalExt.Logic.Zorn.html#14404" class="Bound">¬ub</a><a id="14407" class="Symbol">)</a> <a id="14409" class="Symbol">→</a> <a id="14411" class="Keyword">let</a> <a id="14415" class="Symbol">(</a><a id="14416" href="CubicalExt.Logic.Zorn.html#14416" class="Bound">z∈A</a> <a id="14420" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14422" href="CubicalExt.Logic.Zorn.html#14422" class="Bound">¬z≤y</a><a id="14426" class="Symbol">)</a> <a id="14428" class="Symbol">=</a> <a id="14430" href="CubicalExt.Logic.Classical.html#2630" class="Function">¬→→∧</a> <a id="14435" class="Symbol">(</a><a id="14436" href="CubicalExt.Logic.Zorn.html#14400" class="Bound">z</a> <a id="14438" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="14440" class="Bound">A</a><a id="14441" class="Symbol">)</a> <a id="14443" class="Symbol">⦃</a> <a id="14445" href="CubicalExt.Foundations.Powerset%252A.html#2034" class="Function">∈-isProp</a> <a id="14454" class="Symbol">_</a> <a id="14456" class="Symbol">_</a> <a id="14458" class="Symbol">_</a> <a id="14460" class="Symbol">_</a> <a id="14462" class="Symbol">⦄</a> <a id="14464" class="Symbol">(</a><a id="14465" href="CubicalExt.Logic.Zorn.html#14400" class="Bound">z</a> <a id="14467" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="14469" href="CubicalExt.Logic.Zorn.html#12403" class="Bound">y</a><a id="14470" class="Symbol">)</a> <a id="14472" href="CubicalExt.Logic.Zorn.html#14404" class="Bound">¬ub</a> <a id="14476" class="Keyword">in</a>
        <a id="14487" href="CubicalExt.Logic.Zorn.html#10870" class="Function">≤-trans</a> <a id="14495" href="CubicalExt.Logic.Zorn.html#12438" class="Function">y&#39;</a> <a id="14498" href="CubicalExt.Logic.Zorn.html#14400" class="Bound">z</a> <a id="14500" class="Bound">x</a>
          <a id="14512" class="Symbol">(</a><a id="14513" href="CubicalExt.Functions.Logic.html#849" class="Function">∨-elimʳ</a> <a id="14521" class="Symbol">(</a><a id="14522" href="CubicalExt.Logic.Zorn.html#10777" class="Function">≤-prop</a> <a id="14529" class="Symbol">_</a> <a id="14531" class="Symbol">_)</a> <a id="14534" class="Symbol">(</a><a id="14535" href="CubicalExt.Logic.Zorn.html#12775" class="Function">almostChain&#39;</a> <a id="14548" href="CubicalExt.Logic.Zorn.html#14400" class="Bound">z</a> <a id="14550" class="Symbol">(</a><a id="14551" class="Bound">A⊆</a> <a id="14554" href="CubicalExt.Logic.Zorn.html#14416" class="Bound">z∈A</a><a id="14557" class="Symbol">))</a> <a id="14560" href="CubicalExt.Logic.Zorn.html#14422" class="Bound">¬z≤y</a><a id="14564" class="Symbol">)</a>
          <a id="14576" class="Symbol">(</a><a id="14577" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="14584" class="Bound">A</a> <a id="14586" class="Bound">isChainA</a> <a id="14595" class="Symbol">.</a><a id="14596" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="14600" class="Symbol">.</a><a id="14601" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="14605" href="CubicalExt.Logic.Zorn.html#14400" class="Bound">z</a> <a id="14607" href="CubicalExt.Logic.Zorn.html#14416" class="Bound">z∈A</a><a id="14610" class="Symbol">)</a> <a id="14612" class="Symbol">})</a>
      <a id="14621" class="Symbol">(</a><a id="14622" href="CubicalExt.Logic.Classical.html#2986" class="Function">¬∀→∃¬</a> <a id="14628" href="CubicalExt.Logic.Zorn.html#14361" class="Bound">¬p</a><a id="14630" class="Symbol">)</a>
</pre>
<p>至此 <code>almostChain</code> 证毕. 与 <code>almostChain'</code> 类似地, 我们模式匹配高阶归纳类型先证明了 <code>isChainTower'</code>.</p>
<pre class="Agda">  <a id="Contra.isChainTower&#39;"></a><a id="14725" href="CubicalExt.Logic.Zorn.html#14725" class="Function">isChainTower&#39;</a> <a id="14739" class="Symbol">:</a> <a id="14741" class="Symbol">∀</a> <a id="14743" href="CubicalExt.Logic.Zorn.html#14743" class="Bound">x</a> <a id="14745" href="CubicalExt.Logic.Zorn.html#14745" class="Bound">y</a> <a id="14747" class="Symbol">→</a> <a id="14749" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="14755" href="CubicalExt.Logic.Zorn.html#14743" class="Bound">x</a> <a id="14757" class="Symbol">→</a> <a id="14759" href="CubicalExt.Logic.Zorn.html#14745" class="Bound">y</a> <a id="14761" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="14763" href="CubicalExt.Logic.Zorn.html#11232" class="Function">TowerSetℓ</a> <a id="14773" class="Symbol">→</a> <a id="14775" href="CubicalExt.Logic.Zorn.html#14743" class="Bound">x</a> <a id="14777" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="14779" href="CubicalExt.Logic.Zorn.html#14745" class="Bound">y</a> <a id="14781" href="CubicalExt.Functions.Logic.html#337" class="Function Operator">∨</a> <a id="14783" href="CubicalExt.Logic.Zorn.html#14745" class="Bound">y</a> <a id="14785" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="14787" href="CubicalExt.Logic.Zorn.html#14743" class="Bound">x</a>
  <a id="14791" href="CubicalExt.Logic.Zorn.html#14725" class="Function">isChainTower&#39;</a> <a id="14805" href="CubicalExt.Logic.Zorn.html#14805" class="Bound">x</a> <a id="14807" href="CubicalExt.Logic.Zorn.html#14807" class="Bound">y</a> <a id="14809" href="CubicalExt.Logic.Zorn.html#14809" class="Bound">x∈</a> <a id="14812" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="14814" href="CubicalExt.Logic.Zorn.html#14814" class="Bound">y∈</a> <a id="14817" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="14820" class="Symbol">=</a> <a id="14822" href="CubicalExt.Logic.Zorn.html#11873" class="Function">isChainTower</a> <a id="14835" href="CubicalExt.Logic.Zorn.html#14805" class="Bound">x</a> <a id="14837" href="CubicalExt.Logic.Zorn.html#14807" class="Bound">y</a> <a id="14839" href="CubicalExt.Logic.Zorn.html#14809" class="Bound">x∈</a> <a id="14842" href="CubicalExt.Logic.Zorn.html#14814" class="Bound">y∈</a>
  <a id="14847" href="CubicalExt.Logic.Zorn.html#14725" class="Function">isChainTower&#39;</a> <a id="14861" href="CubicalExt.Logic.Zorn.html#14861" class="Bound">x</a> <a id="14863" href="CubicalExt.Logic.Zorn.html#14863" class="Bound">y</a> <a id="14865" href="CubicalExt.Logic.Zorn.html#14865" class="Bound">x∈</a> <a id="14868" class="Symbol">(</a><a id="14869" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="14877" href="CubicalExt.Logic.Zorn.html#14877" class="Bound">y∈₁</a> <a id="14881" href="CubicalExt.Logic.Zorn.html#14881" class="Bound">y∈₂</a> <a id="14885" href="CubicalExt.Logic.Zorn.html#14885" class="Bound">i</a><a id="14886" class="Symbol">)</a> <a id="14888" class="Symbol">=</a> <a id="14890" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="14898" class="Symbol">(</a><a id="14899" href="CubicalExt.Logic.Zorn.html#14725" class="Function">isChainTower&#39;</a> <a id="14913" href="CubicalExt.Logic.Zorn.html#14861" class="Bound">x</a> <a id="14915" href="CubicalExt.Logic.Zorn.html#14863" class="Bound">y</a> <a id="14917" href="CubicalExt.Logic.Zorn.html#14865" class="Bound">x∈</a> <a id="14920" href="CubicalExt.Logic.Zorn.html#14877" class="Bound">y∈₁</a><a id="14923" class="Symbol">)</a> <a id="14925" class="Symbol">(</a><a id="14926" href="CubicalExt.Logic.Zorn.html#14725" class="Function">isChainTower&#39;</a> <a id="14940" href="CubicalExt.Logic.Zorn.html#14861" class="Bound">x</a> <a id="14942" href="CubicalExt.Logic.Zorn.html#14863" class="Bound">y</a> <a id="14944" href="CubicalExt.Logic.Zorn.html#14865" class="Bound">x∈</a> <a id="14947" href="CubicalExt.Logic.Zorn.html#14881" class="Bound">y∈₂</a><a id="14950" class="Symbol">)</a> <a id="14952" href="CubicalExt.Logic.Zorn.html#14885" class="Bound">i</a>
</pre>
<p>回到 <code>isChainTower</code> 的证明. 由 <code>Tower</code> 的定义, 前提归纳为两种情况.</p>
<ul>
<li><p><code>y</code> (这里重命名为 <code>y'</code>) 其实是某个满足 <code>Tower</code> 的 <code>y</code> 的后继. 这种情况下我们递归调用 <code>almostChain</code>. 分两种情况.</p>
<ul>
<li><code>x ≤ y</code>. 由传递性, <code>x ≤ y'</code>, 即目标的左边成立.</li>
<li><code>y' ≤ x</code>. 目标的右边成立.</li>
</ul></li>
</ul>
<pre class="Agda">  <a id="15164" href="CubicalExt.Logic.Zorn.html#11873" class="Function">isChainTower</a> <a id="15177" href="CubicalExt.Logic.Zorn.html#15177" class="Bound">x</a> <a id="15179" href="CubicalExt.Logic.Zorn.html#15179" class="Bound">y&#39;</a> <a id="15182" href="CubicalExt.Logic.Zorn.html#15182" class="Bound">x∈</a> <a id="15185" class="Symbol">(</a><a id="15186" href="CubicalExt.Logic.Zorn.html#11497" class="InductiveConstructor">includeSuc</a> <a id="15197" href="CubicalExt.Logic.Zorn.html#15197" class="Bound">y</a> <a id="15199" href="CubicalExt.Logic.Zorn.html#15199" class="Bound">y∈</a><a id="15201" class="Symbol">)</a> <a id="15203" class="Symbol">=</a> <a id="15205" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="15209" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a>
    <a id="15221" class="Symbol">(λ{</a> <a id="15225" class="Symbol">(</a><a id="15226" href="Cubical.Data.Sum.Base.html#261" class="InductiveConstructor">⊎.inl</a> <a id="15232" href="CubicalExt.Logic.Zorn.html#15232" class="Bound">x≤y</a><a id="15235" class="Symbol">)</a>  <a id="15238" class="Symbol">→</a> <a id="15240" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="15244" class="Symbol">(</a><a id="15245" href="CubicalExt.Logic.Zorn.html#10870" class="Function">≤-trans</a> <a id="15253" href="CubicalExt.Logic.Zorn.html#15177" class="Bound">x</a> <a id="15255" href="CubicalExt.Logic.Zorn.html#15197" class="Bound">y</a> <a id="15257" href="CubicalExt.Logic.Zorn.html#15179" class="Bound">y&#39;</a> <a id="15260" href="CubicalExt.Logic.Zorn.html#15232" class="Bound">x≤y</a> <a id="15264" href="CubicalExt.Logic.Zorn.html#15339" class="Function">y≤y&#39;</a><a id="15268" class="Symbol">)</a>
      <a id="15276" class="Symbol">;</a> <a id="15278" class="Symbol">(</a><a id="15279" href="Cubical.Data.Sum.Base.html#279" class="InductiveConstructor">⊎.inr</a> <a id="15285" href="CubicalExt.Logic.Zorn.html#15285" class="Bound">y&#39;≤x</a><a id="15289" class="Symbol">)</a> <a id="15291" class="Symbol">→</a> <a id="15293" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="15297" href="CubicalExt.Logic.Zorn.html#15285" class="Bound">y&#39;≤x</a> <a id="15302" class="Symbol">})</a>
    <a id="15309" class="Symbol">(</a><a id="15310" href="CubicalExt.Logic.Zorn.html#12536" class="Function">almostChain</a> <a id="15322" href="CubicalExt.Logic.Zorn.html#15197" class="Bound">y</a> <a id="15324" href="CubicalExt.Logic.Zorn.html#15199" class="Bound">y∈</a> <a id="15327" href="CubicalExt.Logic.Zorn.html#15177" class="Bound">x</a> <a id="15329" href="CubicalExt.Logic.Zorn.html#15182" class="Bound">x∈</a><a id="15331" class="Symbol">)</a> <a id="15333" class="Keyword">where</a> <a id="15339" href="CubicalExt.Logic.Zorn.html#15339" class="Function">y≤y&#39;</a> <a id="15344" class="Symbol">=</a> <a id="15346" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="15353" href="CubicalExt.Logic.Zorn.html#15197" class="Bound">y</a> <a id="15355" class="Symbol">.</a><a id="15356" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15360" class="Symbol">.</a><a id="15361" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<ul>
<li><code>y</code> 其实是 <code>TowerSetℓ</code> 的子集: 链 <code>A</code> 的上确界. 这种情况与 <code>almostChain</code> 的相应情况相当类似, 只不过变量名字换了一下.</li>
</ul>
<pre class="Agda">  <a id="15464" href="CubicalExt.Logic.Zorn.html#11873" class="Function">isChainTower</a> <a id="15477" href="CubicalExt.Logic.Zorn.html#15477" class="Bound">x</a> <a id="15479" href="CubicalExt.Logic.Zorn.html#15479" class="Bound">y</a> <a id="15481" href="CubicalExt.Logic.Zorn.html#15481" class="Bound">x∈</a> <a id="15484" class="Symbol">(</a><a id="15485" href="CubicalExt.Logic.Zorn.html#11556" class="InductiveConstructor">includeSup</a> <a id="15496" href="CubicalExt.Logic.Zorn.html#15496" class="Bound">A</a> <a id="15498" href="CubicalExt.Logic.Zorn.html#15498" class="Bound">A⊆</a> <a id="15501" href="CubicalExt.Logic.Zorn.html#15501" class="Bound">isChainA</a><a id="15509" class="Symbol">)</a> <a id="15511" class="Keyword">with</a> <a id="15516" href="CubicalExt.Logic.Zorn.html#10512" class="Bound">em</a> <a id="15519" class="Symbol">{</a><a id="15520" class="Argument">P</a> <a id="15522" class="Symbol">=</a> <a id="15524" href="CubicalExt.Logic.Zorn.html#3285" class="Function">upperBound</a> <a id="15535" href="CubicalExt.Logic.Zorn.html#15496" class="Bound">A</a> <a id="15537" href="CubicalExt.Logic.Zorn.html#15477" class="Bound">x</a><a id="15538" class="Symbol">}</a>
  <a id="15542" class="Symbol">...</a> <a id="15546" class="Symbol">|</a> <a id="15548" href="Cubical.Relation.Nullary.Base.html#478" class="InductiveConstructor">yes</a> <a id="15552" href="CubicalExt.Logic.Zorn.html#15552" class="Bound">p</a> <a id="15554" class="Symbol">=</a> <a id="15556" href="Cubical.Functions.Logic.html#3417" class="Function">inr</a> <a id="15560" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="15562" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="15569" class="Bound">A</a> <a id="15571" class="Bound">isChainA</a> <a id="15580" class="Symbol">.</a><a id="15581" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15585" class="Symbol">.</a><a id="15586" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15590" class="Bound">x</a> <a id="15592" href="CubicalExt.Logic.Zorn.html#15552" class="Bound">p</a>
  <a id="15596" class="Symbol">...</a> <a id="15600" class="Symbol">|</a> <a id="15602" href="Cubical.Relation.Nullary.Base.html#505" class="InductiveConstructor">no</a> <a id="15605" href="CubicalExt.Logic.Zorn.html#15605" class="Bound">¬p</a> <a id="15608" class="Symbol">=</a> <a id="15610" href="Cubical.Functions.Logic.html#3378" class="Function">inl</a> <a id="15614" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="15616" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="15620" class="Symbol">(</a><a id="15621" href="CubicalExt.Logic.Zorn.html#10777" class="Function">≤-prop</a> <a id="15628" class="Symbol">_</a> <a id="15630" class="Symbol">_)</a>
    <a id="15637" class="Symbol">(λ{</a> <a id="15641" class="Symbol">(</a><a id="15642" href="CubicalExt.Logic.Zorn.html#15642" class="Bound">z</a> <a id="15644" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="15646" href="CubicalExt.Logic.Zorn.html#15646" class="Bound">¬ub</a><a id="15649" class="Symbol">)</a> <a id="15651" class="Symbol">→</a> <a id="15653" class="Keyword">let</a> <a id="15657" class="Symbol">(</a><a id="15658" href="CubicalExt.Logic.Zorn.html#15658" class="Bound">z∈A</a> <a id="15662" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="15664" href="CubicalExt.Logic.Zorn.html#15664" class="Bound">¬z≤x</a><a id="15668" class="Symbol">)</a> <a id="15670" class="Symbol">=</a> <a id="15672" href="CubicalExt.Logic.Classical.html#2630" class="Function">¬→→∧</a> <a id="15677" class="Symbol">(</a><a id="15678" href="CubicalExt.Logic.Zorn.html#15642" class="Bound">z</a> <a id="15680" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="15682" class="Bound">A</a><a id="15683" class="Symbol">)</a> <a id="15685" class="Symbol">⦃</a> <a id="15687" href="CubicalExt.Foundations.Powerset%252A.html#2034" class="Function">∈-isProp</a> <a id="15696" class="Symbol">_</a> <a id="15698" class="Symbol">_</a> <a id="15700" class="Symbol">_</a> <a id="15702" class="Symbol">_</a> <a id="15704" class="Symbol">⦄</a> <a id="15706" class="Symbol">(</a><a id="15707" href="CubicalExt.Logic.Zorn.html#15642" class="Bound">z</a> <a id="15709" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="15711" class="Bound">x</a><a id="15712" class="Symbol">)</a> <a id="15714" href="CubicalExt.Logic.Zorn.html#15646" class="Bound">¬ub</a> <a id="15718" class="Keyword">in</a>
      <a id="15727" href="CubicalExt.Logic.Zorn.html#10870" class="Function">≤-trans</a> <a id="15735" class="Bound">x</a> <a id="15737" href="CubicalExt.Logic.Zorn.html#15642" class="Bound">z</a> <a id="15739" class="Bound">y</a>
        <a id="15749" class="Symbol">(</a><a id="15750" href="CubicalExt.Functions.Logic.html#721" class="Function">∨-elimˡ</a> <a id="15758" class="Symbol">(</a><a id="15759" href="CubicalExt.Logic.Zorn.html#10777" class="Function">≤-prop</a> <a id="15766" class="Symbol">_</a> <a id="15768" class="Symbol">_)</a> <a id="15771" class="Symbol">(</a><a id="15772" href="CubicalExt.Logic.Zorn.html#14725" class="Function">isChainTower&#39;</a> <a id="15786" class="Bound">x</a> <a id="15788" href="CubicalExt.Logic.Zorn.html#15642" class="Bound">z</a> <a id="15790" class="Bound">x∈</a> <a id="15793" class="Symbol">(</a><a id="15794" class="Bound">A⊆</a> <a id="15797" href="CubicalExt.Logic.Zorn.html#15658" class="Bound">z∈A</a><a id="15800" class="Symbol">))</a> <a id="15803" href="CubicalExt.Logic.Zorn.html#15664" class="Bound">¬z≤x</a><a id="15807" class="Symbol">)</a>
        <a id="15817" class="Symbol">(</a><a id="15818" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="15825" class="Bound">A</a> <a id="15827" class="Bound">isChainA</a> <a id="15836" class="Symbol">.</a><a id="15837" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="15841" class="Symbol">.</a><a id="15842" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="15846" href="CubicalExt.Logic.Zorn.html#15642" class="Bound">z</a> <a id="15848" href="CubicalExt.Logic.Zorn.html#15658" class="Bound">z∈A</a><a id="15851" class="Symbol">)</a> <a id="15853" class="Symbol">})</a>
    <a id="15860" class="Symbol">(</a><a id="15861" href="CubicalExt.Logic.Classical.html#2986" class="Function">¬∀→∃¬</a> <a id="15867" href="CubicalExt.Logic.Zorn.html#15605" class="Bound">¬p</a><a id="15869" class="Symbol">)</a>
</pre>
<h3 id="矛盾">矛盾</h3>
<p>证明了 <code>TowerSet</code> 是链之后, 构造矛盾就非常简单了. 由前提, <code>TowerSet</code> 可以取到上确界 <code>sup</code>, 且 <code>sup</code> 可以取到后继 <code>suc</code>.</p>
<pre class="Agda">  <a id="Contra.Σsup"></a><a id="15981" href="CubicalExt.Logic.Zorn.html#15981" class="Function">Σsup</a> <a id="15986" class="Symbol">=</a> <a id="15988" href="CubicalExt.Logic.Zorn.html#10590" class="Bound">hasSup</a> <a id="15995" href="CubicalExt.Logic.Zorn.html#11281" class="Function">TowerSet</a> <a id="16004" href="CubicalExt.Logic.Zorn.html#12028" class="Function">isChainTowerSet</a>
  <a id="Contra.sup"></a><a id="16022" href="CubicalExt.Logic.Zorn.html#16022" class="Function">sup</a> <a id="16026" class="Symbol">=</a> <a id="16028" href="CubicalExt.Logic.Zorn.html#15981" class="Function">Σsup</a> <a id="16033" class="Symbol">.</a><a id="16034" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
  <a id="Contra.ubhood"></a><a id="16040" href="CubicalExt.Logic.Zorn.html#16040" class="Function">ubhood</a> <a id="16047" class="Symbol">=</a> <a id="16049" href="CubicalExt.Logic.Zorn.html#15981" class="Function">Σsup</a> <a id="16054" class="Symbol">.</a><a id="16055" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16059" class="Symbol">.</a><a id="16060" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>

  <a id="Contra.Σsuc"></a><a id="16067" href="CubicalExt.Logic.Zorn.html#16067" class="Function">Σsuc</a> <a id="16072" class="Symbol">=</a> <a id="16074" href="CubicalExt.Logic.Zorn.html#10626" class="Bound">hasSuc</a> <a id="16081" href="CubicalExt.Logic.Zorn.html#16022" class="Function">sup</a>
  <a id="Contra.suc"></a><a id="16087" href="CubicalExt.Logic.Zorn.html#16087" class="Function">suc</a> <a id="16091" class="Symbol">=</a> <a id="16093" href="CubicalExt.Logic.Zorn.html#16067" class="Function">Σsuc</a> <a id="16098" class="Symbol">.</a><a id="16099" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
  <a id="Contra.sup≤suc"></a><a id="16105" href="CubicalExt.Logic.Zorn.html#16105" class="Function">sup≤suc</a> <a id="16113" class="Symbol">=</a> <a id="16115" href="CubicalExt.Logic.Zorn.html#16067" class="Function">Σsuc</a> <a id="16120" class="Symbol">.</a><a id="16121" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16125" class="Symbol">.</a><a id="16126" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
  <a id="Contra.sup≢suc"></a><a id="16132" href="CubicalExt.Logic.Zorn.html#16132" class="Function">sup≢suc</a> <a id="16140" class="Symbol">=</a> <a id="16142" href="CubicalExt.Logic.Zorn.html#16067" class="Function">Σsuc</a> <a id="16147" class="Symbol">.</a><a id="16148" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16152" class="Symbol">.</a><a id="16153" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="16157" class="Symbol">.</a><a id="16158" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
</pre>
<p>按 <code>Tower</code> 的定义, <code>sup</code> 也满足它. 这里命题宇宙调整 (propositional resizing) 起了关键作用.</p>
<pre class="Agda">  <a id="Contra.sup∈Tower"></a><a id="16247" href="CubicalExt.Logic.Zorn.html#16247" class="Function">sup∈Tower</a> <a id="16257" class="Symbol">:</a> <a id="16259" href="CubicalExt.Logic.Zorn.html#11178" class="Datatype">Tower</a> <a id="16265" href="CubicalExt.Logic.Zorn.html#16022" class="Function">sup</a>
  <a id="16271" href="CubicalExt.Logic.Zorn.html#16247" class="Function">sup∈Tower</a> <a id="16281" class="Symbol">=</a> <a id="16283" href="CubicalExt.Logic.Zorn.html#11556" class="InductiveConstructor">includeSup</a> <a id="16294" href="CubicalExt.Logic.Zorn.html#11281" class="Function">TowerSet</a> <a id="16303" href="CubicalExt.Logic.Classical.html#2155" class="Function">unresize</a> <a id="16312" href="CubicalExt.Logic.Zorn.html#12028" class="Function">isChainTowerSet</a>
</pre>
<p>这样, 按 <code>TowerSet</code> 的定义, <code>suc</code> 也在 <code>TowerSet</code> 里.</p>
<pre class="Agda">  <a id="Contra.suc∈TowerSet"></a><a id="16389" href="CubicalExt.Logic.Zorn.html#16389" class="Function">suc∈TowerSet</a> <a id="16402" class="Symbol">:</a> <a id="16404" href="CubicalExt.Logic.Zorn.html#16087" class="Function">suc</a> <a id="16408" href="CubicalExt.Foundations.Powerset%252A.html#1866" class="Function Operator">∈</a> <a id="16410" href="CubicalExt.Logic.Zorn.html#11281" class="Function">TowerSet</a>
  <a id="16421" href="CubicalExt.Logic.Zorn.html#16389" class="Function">suc∈TowerSet</a> <a id="16434" class="Symbol">=</a> <a id="16436" href="CubicalExt.Logic.Classical.html#2032" class="Function">resize</a> <a id="16443" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="16445" href="Cubical.HITs.PropositionalTruncation.Properties.html#6519" class="Function">map</a> <a id="16449" class="Symbol">(</a><a id="16450" href="CubicalExt.Logic.Zorn.html#11497" class="InductiveConstructor">includeSuc</a> <a id="16461" href="CubicalExt.Logic.Zorn.html#16022" class="Function">sup</a><a id="16464" class="Symbol">)</a> <a id="16466" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="16468" href="CubicalExt.Logic.Zorn.html#16247" class="Function">sup∈Tower</a> <a id="16478" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
</pre>
<p>但是 <code>suc</code> 是 <code>sup</code> 的后继, 与 <code>sup</code> 是 <code>TowerSet</code> 的上确界矛盾.</p>
<pre class="Agda">  <a id="Contra.false"></a><a id="16548" href="CubicalExt.Logic.Zorn.html#16548" class="Function">false</a> <a id="16554" class="Symbol">:</a> <a id="16556" href="Cubical.Data.Empty.Base.html#145" class="Datatype">⊥</a>
  <a id="16560" href="CubicalExt.Logic.Zorn.html#16548" class="Function">false</a> <a id="16566" class="Symbol">=</a> <a id="16568" href="CubicalExt.Logic.Zorn.html#16132" class="Function">sup≢suc</a> <a id="16576" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="16578" href="CubicalExt.Logic.Zorn.html#10834" class="Function">≤-antisym</a> <a id="16588" class="Symbol">_</a> <a id="16590" class="Symbol">_</a> <a id="16592" href="CubicalExt.Logic.Zorn.html#16105" class="Function">sup≤suc</a> <a id="16600" href="CubicalExt.Logic.Zorn.html#16618" class="Function">suc≤sup</a> <a id="16608" class="Keyword">where</a>
    <a id="16618" href="CubicalExt.Logic.Zorn.html#16618" class="Function">suc≤sup</a> <a id="16626" class="Symbol">:</a> <a id="16628" href="CubicalExt.Logic.Zorn.html#16087" class="Function">suc</a> <a id="16632" href="CubicalExt.Logic.Zorn.html#10546" class="Bound Operator">≤</a> <a id="16634" href="CubicalExt.Logic.Zorn.html#16022" class="Function">sup</a>
    <a id="16642" href="CubicalExt.Logic.Zorn.html#16618" class="Function">suc≤sup</a> <a id="16650" class="Symbol">=</a> <a id="16652" href="CubicalExt.Logic.Zorn.html#16040" class="Function">ubhood</a> <a id="16659" href="CubicalExt.Logic.Zorn.html#16087" class="Function">suc</a> <a id="16663" href="CubicalExt.Logic.Zorn.html#16389" class="Function">suc∈TowerSet</a>
</pre>
<h2 id="选择公理">选择公理</h2>
<p>我们将假设如下形式的选择公理:</p>
<blockquote>
<p>非空集合的笛卡尔积非空</p>
</blockquote>
<p>在同伦类型论中表述为 :</p>
<p><code>(∀ x → ∥ B x ∥₁) → ∥ ∀ x → B x ∥₁</code></p>
<p>其中 <code>x</code> 具有类型 <code>A</code>, 而 <code>A</code> 和每个 <code>B x</code> 都是集合.</p>
<h2 id="佐恩引理的证明">佐恩引理的证明</h2>
<p>假设选择公理, 给定 <code>U</code> 上的二元关系 <code>≤</code>.</p>
<pre class="Agda"><a id="16861" class="Keyword">module</a> <a id="16868" href="CubicalExt.Logic.Zorn.html#16868" class="Module">_</a> <a id="16870" class="Symbol">(</a><a id="16871" href="CubicalExt.Logic.Zorn.html#16871" class="Bound">ac</a> <a id="16874" class="Symbol">:</a> <a id="16876" class="Symbol">∀</a> <a id="16878" class="Symbol">{</a><a id="16879" href="CubicalExt.Logic.Zorn.html#16879" class="Bound">ℓ</a> <a id="16881" href="CubicalExt.Logic.Zorn.html#16881" class="Bound">ℓ&#39;</a><a id="16883" class="Symbol">}</a> <a id="16885" class="Symbol">→</a> <a id="16887" href="CubicalExt.Axiom.Choice.html#1200" class="Function">AC</a> <a id="16890" href="CubicalExt.Logic.Zorn.html#16879" class="Bound">ℓ</a> <a id="16892" href="CubicalExt.Logic.Zorn.html#16881" class="Bound">ℓ&#39;</a><a id="16894" class="Symbol">)</a> <a id="16896" class="Symbol">{</a><a id="16897" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="16899" class="Symbol">:</a> <a id="16901" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="16906" href="CubicalExt.Logic.Zorn.html#1767" class="Generalizable">u</a><a id="16907" class="Symbol">}</a> <a id="16909" class="Symbol">{</a><a id="16910" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">_≤_</a> <a id="16914" class="Symbol">:</a> <a id="16916" href="Cubical.Relation.Binary.Base.html#491" class="Function">Rel</a> <a id="16920" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="16922" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="16924" href="CubicalExt.Logic.Zorn.html#1769" class="Generalizable">r</a><a id="16925" class="Symbol">}</a> <a id="16927" class="Keyword">where</a>
  <a id="16935" class="Keyword">open</a> <a id="16940" class="Keyword">import</a> <a id="16947" href="CubicalExt.Logic.ClassicalChoice.html" class="Module">CubicalExt.Logic.ClassicalChoice</a> <a id="16980" href="CubicalExt.Logic.Zorn.html#16871" class="Bound">ac</a>
  <a id="16985" class="Keyword">open</a> <a id="16990" href="CubicalExt.Logic.Zorn.html#2007" class="Module">Order</a> <a id="16996" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">_≤_</a>
</pre>
<p>假设 <code>U</code> 是偏序集, 且不存在最大元, 我们证明 “<code>U</code> 无界” 的命题截断 <code>∥ unbound ∥₁</code> 成立. 不难发现, 目标具有适用于选择公理的形式. 选择公理要求 <code>U</code> 是集合, 且 <code>U</code> 配备上无界条件也是集合, 这些显然成立. 现在只需证对任意 <code>x</code> <strong>存在</strong> <code>y</code> 严格大于它.</p>
<pre class="Agda">  <a id="17173" href="CubicalExt.Logic.Zorn.html#17173" class="Function">noMaximum→unbound</a> <a id="17191" class="Symbol">:</a> <a id="17193" href="CubicalExt.Logic.Zorn.html#2256" class="Function">isPoset</a> <a id="17201" class="Symbol">→</a> <a id="17203" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="17205" class="Symbol">(</a><a id="17206" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="17209" href="CubicalExt.Logic.Zorn.html#17209" class="Bound">m</a> <a id="17211" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="17213" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="17215" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="17217" href="CubicalExt.Logic.Zorn.html#2780" class="Function">maximum</a> <a id="17225" href="CubicalExt.Logic.Zorn.html#17209" class="Bound">m</a><a id="17226" class="Symbol">)</a> <a id="17228" class="Symbol">→</a> <a id="17230" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥</a> <a id="17232" href="CubicalExt.Logic.Zorn.html#2444" class="Function">unbound</a> <a id="17240" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥₁</a>
  <a id="17245" href="CubicalExt.Logic.Zorn.html#17173" class="Function">noMaximum→unbound</a> <a id="17263" href="CubicalExt.Logic.Zorn.html#17263" class="Bound">≤-poset</a> <a id="17271" href="CubicalExt.Logic.Zorn.html#17271" class="Bound">noMax</a> <a id="17277" class="Symbol">=</a> <a id="17279" href="CubicalExt.Logic.Zorn.html#16871" class="Bound">ac</a> <a id="17282" href="CubicalExt.Logic.Zorn.html#17304" class="Function">Uset</a> <a id="17287" href="CubicalExt.Logic.Zorn.html#17359" class="Function">Σset</a> <a id="17292" href="CubicalExt.Logic.Zorn.html#17990" class="Function">H</a> <a id="17294" class="Keyword">where</a>
    <a id="17304" href="CubicalExt.Logic.Zorn.html#17304" class="Function">Uset</a> <a id="17309" class="Symbol">=</a> <a id="17311" href="CubicalExt.Logic.Zorn.html#17263" class="Bound">≤-poset</a> <a id="17319" class="Symbol">.</a><a id="17320" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="17328" href="CubicalExt.Logic.Zorn.html#17328" class="Function">≤-prop</a> <a id="17335" class="Symbol">=</a> <a id="17337" href="CubicalExt.Logic.Zorn.html#17263" class="Bound">≤-poset</a> <a id="17345" class="Symbol">.</a><a id="17346" href="Agda.Builtin.Sigma.html#246" class="Field">snd</a> <a id="17350" class="Symbol">.</a><a id="17351" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a>
    <a id="17359" href="CubicalExt.Logic.Zorn.html#17359" class="Function">Σset</a> <a id="17364" class="Symbol">:</a> <a id="17366" class="Symbol">∀</a> <a id="17368" href="CubicalExt.Logic.Zorn.html#17368" class="Bound">x</a> <a id="17370" class="Symbol">→</a> <a id="17372" href="Cubical.Foundations.Prelude.html#14301" class="Function">isSet</a> <a id="17378" class="Symbol">(</a><a id="17379" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="17382" href="CubicalExt.Logic.Zorn.html#17382" class="Bound">x&#39;</a> <a id="17385" href="Cubical.Core.Primitives.html#6268" class="Function">∈</a> <a id="17387" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="17389" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="17391" class="Symbol">(</a><a id="17392" href="CubicalExt.Logic.Zorn.html#17368" class="Bound">x</a> <a id="17394" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">≤</a> <a id="17396" href="CubicalExt.Logic.Zorn.html#17382" class="Bound">x&#39;</a> <a id="17399" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="17401" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="17403" href="CubicalExt.Logic.Zorn.html#17368" class="Bound">x</a> <a id="17405" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="17407" href="CubicalExt.Logic.Zorn.html#17382" class="Bound">x&#39;</a><a id="17409" class="Symbol">))</a>
    <a id="17416" href="CubicalExt.Logic.Zorn.html#17359" class="Function">Σset</a> <a id="17421" class="Symbol">=</a> <a id="17423" class="Symbol">λ</a> <a id="17425" href="CubicalExt.Logic.Zorn.html#17425" class="Bound">_</a> <a id="17427" class="Symbol">→</a> <a id="17429" href="Cubical.Foundations.HLevels.html#12848" class="Function">isSetΣ</a> <a id="17436" href="CubicalExt.Logic.Zorn.html#17304" class="Function">Uset</a> <a id="17441" class="Symbol">λ</a> <a id="17443" href="CubicalExt.Logic.Zorn.html#17443" class="Bound">_</a> <a id="17445" class="Symbol">→</a> <a id="17447" href="Cubical.Foundations.Prelude.html#18523" class="Function">isProp→isSet</a> <a id="17460" href="Cubical.Foundations.Function.html#527" class="Function Operator">$</a> <a id="17462" href="Cubical.Foundations.HLevels.html#12387" class="Function">isPropΣ</a> <a id="17470" class="Symbol">(</a><a id="17471" href="CubicalExt.Logic.Zorn.html#17328" class="Function">≤-prop</a> <a id="17478" class="Symbol">_</a> <a id="17480" class="Symbol">_)</a> <a id="17483" class="Symbol">λ</a> <a id="17485" href="CubicalExt.Logic.Zorn.html#17485" class="Bound">_</a> <a id="17487" class="Symbol">→</a> <a id="17489" href="Cubical.Foundations.HLevels.html#16363" class="Function">isPropΠ</a> <a id="17497" class="Symbol">λ</a> <a id="17499" href="CubicalExt.Logic.Zorn.html#17499" class="Bound">_</a> <a id="17501" class="Symbol">→</a> <a id="17503" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
</pre>
<p>注意 <code>≤</code> 和 <code>U</code> 上的 <code>≡</code> 都是命题. 这说明接下来证明涉及这些关系的目标时使用排中律是合法的.</p>
<pre class="Agda">    <a id="17584" class="Keyword">instance</a>
      <a id="17599" href="CubicalExt.Logic.Zorn.html#17599" class="Function">≤-propImplicit</a> <a id="17614" class="Symbol">:</a> <a id="17616" class="Symbol">{</a><a id="17617" href="CubicalExt.Logic.Zorn.html#17617" class="Bound">x</a> <a id="17619" href="CubicalExt.Logic.Zorn.html#17619" class="Bound">y</a> <a id="17621" class="Symbol">:</a> <a id="17623" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a><a id="17624" class="Symbol">}</a> <a id="17626" class="Symbol">→</a> <a id="17628" href="CubicalExt.Axiom.ExcludedMiddle.html#375" class="Function">isPropImplicit</a> <a id="17643" class="Symbol">(</a><a id="17644" href="CubicalExt.Logic.Zorn.html#17617" class="Bound">x</a> <a id="17646" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">≤</a> <a id="17648" href="CubicalExt.Logic.Zorn.html#17619" class="Bound">y</a><a id="17649" class="Symbol">)</a>
      <a id="17657" href="CubicalExt.Logic.Zorn.html#17599" class="Function">≤-propImplicit</a> <a id="17672" class="Symbol">=</a> <a id="17674" href="CubicalExt.Logic.Zorn.html#17328" class="Function">≤-prop</a> <a id="17681" class="Symbol">_</a> <a id="17683" class="Symbol">_</a> <a id="17685" class="Symbol">_</a> <a id="17687" class="Symbol">_</a>
      <a id="17695" href="CubicalExt.Logic.Zorn.html#17695" class="Function">≡-propImplicit</a> <a id="17710" class="Symbol">:</a> <a id="17712" class="Symbol">{</a><a id="17713" href="CubicalExt.Logic.Zorn.html#17713" class="Bound">x</a> <a id="17715" href="CubicalExt.Logic.Zorn.html#17715" class="Bound">y</a> <a id="17717" class="Symbol">:</a> <a id="17719" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a><a id="17720" class="Symbol">}</a> <a id="17722" class="Symbol">→</a> <a id="17724" href="CubicalExt.Axiom.ExcludedMiddle.html#375" class="Function">isPropImplicit</a> <a id="17739" class="Symbol">(</a><a id="17740" href="CubicalExt.Logic.Zorn.html#17713" class="Bound">x</a> <a id="17742" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="17744" href="CubicalExt.Logic.Zorn.html#17715" class="Bound">y</a><a id="17745" class="Symbol">)</a>
      <a id="17753" href="CubicalExt.Logic.Zorn.html#17695" class="Function">≡-propImplicit</a> <a id="17768" class="Symbol">=</a> <a id="17770" href="CubicalExt.Logic.Zorn.html#17304" class="Function">Uset</a> <a id="17775" class="Symbol">_</a> <a id="17777" class="Symbol">_</a> <a id="17779" class="Symbol">_</a> <a id="17781" class="Symbol">_</a>
</pre>
<p>不存在最大元说明对任意 <code>x</code> 存在 <code>x'</code> 满足 <code>¬ (x ≤ x' → x ≡ x')</code>. 用排中律将这部分转化成 <code>x ≤ x' ∧ ¬ x ≡ x'</code> 就证明了 <code>x'</code> 严格大于 <code>x</code>.</p>
<pre class="Agda">    <a id="17903" href="CubicalExt.Logic.Zorn.html#17903" class="Function">H₀</a> <a id="17906" class="Symbol">:</a> <a id="17908" class="Symbol">∀</a> <a id="17910" href="CubicalExt.Logic.Zorn.html#17910" class="Bound">x</a> <a id="17912" class="Symbol">→</a> <a id="17914" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="17917" href="CubicalExt.Logic.Zorn.html#17917" class="Bound">x&#39;</a> <a id="17920" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="17922" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="17924" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="17926" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="17928" class="Symbol">(</a><a id="17929" href="CubicalExt.Logic.Zorn.html#17910" class="Bound">x</a> <a id="17931" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">≤</a> <a id="17933" href="CubicalExt.Logic.Zorn.html#17917" class="Bound">x&#39;</a> <a id="17936" class="Symbol">→</a> <a id="17938" href="CubicalExt.Logic.Zorn.html#17910" class="Bound">x</a> <a id="17940" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="17942" href="CubicalExt.Logic.Zorn.html#17917" class="Bound">x&#39;</a><a id="17944" class="Symbol">)</a>
    <a id="17950" href="CubicalExt.Logic.Zorn.html#17903" class="Function">H₀</a> <a id="17953" href="CubicalExt.Logic.Zorn.html#17953" class="Bound">x</a> <a id="17955" class="Symbol">=</a> <a id="17957" href="CubicalExt.Logic.Classical.html#2986" class="Function">¬∀→∃¬</a> <a id="17963" class="Symbol">λ</a> <a id="17965" href="CubicalExt.Logic.Zorn.html#17965" class="Bound">H</a> <a id="17967" class="Symbol">→</a> <a id="17969" href="CubicalExt.Logic.Zorn.html#17271" class="Bound">noMax</a> <a id="17975" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="17977" href="CubicalExt.Logic.Zorn.html#17953" class="Bound">x</a> <a id="17979" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="17981" href="CubicalExt.Logic.Zorn.html#17965" class="Bound">H</a> <a id="17983" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a>
    <a id="17990" href="CubicalExt.Logic.Zorn.html#17990" class="Function">H</a> <a id="17992" class="Symbol">:</a> <a id="17994" class="Symbol">∀</a> <a id="17996" href="CubicalExt.Logic.Zorn.html#17996" class="Bound">x</a> <a id="17998" class="Symbol">→</a> <a id="18000" href="Cubical.Data.Sigma.Base.html#682" class="Function">∃[</a> <a id="18003" href="CubicalExt.Logic.Zorn.html#18003" class="Bound">x&#39;</a> <a id="18006" href="Cubical.Data.Sigma.Base.html#682" class="Function">∈</a> <a id="18008" href="CubicalExt.Logic.Zorn.html#16897" class="Bound">U</a> <a id="18010" href="Cubical.Data.Sigma.Base.html#682" class="Function">]</a> <a id="18012" class="Symbol">(</a><a id="18013" href="CubicalExt.Logic.Zorn.html#17996" class="Bound">x</a> <a id="18015" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">≤</a> <a id="18017" href="CubicalExt.Logic.Zorn.html#18003" class="Bound">x&#39;</a> <a id="18020" href="CubicalExt.Functions.Logic.html#359" class="Function Operator">∧</a> <a id="18022" href="Cubical.Relation.Nullary.Base.html#355" class="Function Operator">¬</a> <a id="18024" href="CubicalExt.Logic.Zorn.html#17996" class="Bound">x</a> <a id="18026" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="18028" href="CubicalExt.Logic.Zorn.html#18003" class="Bound">x&#39;</a><a id="18030" class="Symbol">)</a>
    <a id="18036" href="CubicalExt.Logic.Zorn.html#17990" class="Function">H</a> <a id="18038" href="CubicalExt.Logic.Zorn.html#18038" class="Bound">x</a> <a id="18040" class="Symbol">=</a> <a id="18042" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="18046" href="Cubical.HITs.PropositionalTruncation.Base.html#308" class="InductiveConstructor">squash₁</a> <a id="18054" class="Symbol">(λ</a> <a id="18057" class="Symbol">{</a> <a id="18059" class="Symbol">(</a><a id="18060" href="CubicalExt.Logic.Zorn.html#18060" class="Bound">x&#39;</a> <a id="18063" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="18065" href="CubicalExt.Logic.Zorn.html#18065" class="Bound">H</a><a id="18066" class="Symbol">)</a> <a id="18068" class="Symbol">→</a> <a id="18070" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣</a> <a id="18072" href="CubicalExt.Logic.Zorn.html#18060" class="Bound">x&#39;</a> <a id="18075" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="18077" href="CubicalExt.Logic.Classical.html#2630" class="Function">¬→→∧</a> <a id="18082" class="Symbol">(</a><a id="18083" href="CubicalExt.Logic.Zorn.html#18038" class="Bound">x</a> <a id="18085" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">≤</a> <a id="18087" href="CubicalExt.Logic.Zorn.html#18060" class="Bound">x&#39;</a><a id="18089" class="Symbol">)</a> <a id="18091" class="Symbol">(</a><a id="18092" href="CubicalExt.Logic.Zorn.html#18038" class="Bound">x</a> <a id="18094" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="18096" href="CubicalExt.Logic.Zorn.html#18060" class="Bound">x&#39;</a><a id="18098" class="Symbol">)</a> <a id="18100" href="CubicalExt.Logic.Zorn.html#18065" class="Bound">H</a> <a id="18102" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣₁</a> <a id="18105" class="Symbol">})</a> <a id="18108" class="Symbol">(</a><a id="18109" href="CubicalExt.Logic.Zorn.html#17903" class="Function">H₀</a> <a id="18112" href="CubicalExt.Logic.Zorn.html#18038" class="Bound">x</a><a id="18113" class="Symbol">)</a>
</pre>
<p>最后佐恩引理的证明就非常简单了. 用反证法, 假设 <code>U</code> 没有最大元, 由上一条引理有 <code>∥ unbound ∥₁</code>. 这时只需 <code>rec</code> 到 <code>⊥</code>, 所以可以去掉截断, 拿到完整的 <code>unbound</code>. 这正好是 <code>⪯-successvie</code> 的前提, 于是我们可以证明链集的任意链都能取上界且链集是后继的. 由”塔”的构造我们知道这是矛盾的.</p>
<pre class="Agda">  <a id="18308" href="CubicalExt.Logic.Zorn.html#18308" class="Function">zorn</a> <a id="18313" class="Symbol">:</a> <a id="18315" href="CubicalExt.Logic.Zorn.html#3923" class="Function">Zorn</a>
  <a id="18322" href="CubicalExt.Logic.Zorn.html#18308" class="Function">zorn</a> <a id="18327" href="CubicalExt.Logic.Zorn.html#18327" class="Bound">≤-poset</a> <a id="18335" href="CubicalExt.Logic.Zorn.html#18335" class="Bound">hasUb</a> <a id="18341" class="Symbol">=</a> <a id="18343" href="CubicalExt.Logic.Classical.html#2297" class="Function">byContra</a> <a id="18352" class="Symbol">λ</a> <a id="18354" href="CubicalExt.Logic.Zorn.html#18354" class="Bound">noMax</a> <a id="18360" class="Symbol">→</a> <a id="18362" href="Cubical.HITs.PropositionalTruncation.Properties.html#894" class="Function">rec</a> <a id="18366" href="Cubical.Data.Empty.Properties.html#228" class="Function">isProp⊥</a>
    <a id="18378" class="Symbol">(</a><a id="18379" href="CubicalExt.Logic.Zorn.html#16548" class="Function">Contra.false</a> <a id="18392" href="CubicalExt.Logic.Zorn.html#5184" class="Function">⪯-po</a> <a id="18397" href="CubicalExt.Logic.Zorn.html#7123" class="Function">⪯-allChainHasSup</a> <a id="18414" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="18416" href="CubicalExt.Logic.Zorn.html#7489" class="Function">⪯-successvie</a> <a id="18429" href="CubicalExt.Logic.Zorn.html#18327" class="Bound">≤-poset</a> <a id="18437" href="CubicalExt.Logic.Zorn.html#18335" class="Bound">hasUb</a><a id="18442" class="Symbol">)</a>
    <a id="18448" class="Symbol">(</a><a id="18449" href="CubicalExt.Logic.Zorn.html#17173" class="Function">noMaximum→unbound</a> <a id="18467" href="CubicalExt.Logic.Zorn.html#18327" class="Bound">≤-poset</a> <a id="18475" href="CubicalExt.Logic.Zorn.html#18354" class="Bound">noMax</a><a id="18480" class="Symbol">)</a>
    <a id="18486" class="Keyword">where</a> <a id="18492" class="Keyword">open</a> <a id="18497" href="CubicalExt.Logic.Zorn.html#4359" class="Module">Chain</a> <a id="18503" href="CubicalExt.Logic.Zorn.html#16910" class="Bound Operator">_≤_</a>
</pre>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
